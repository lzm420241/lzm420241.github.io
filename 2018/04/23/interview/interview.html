<hr>
<p>title: 前端常见面试题归纳(一)<br>date: 2017-05-21 09:54:17<br>categories: 前端知识点总结<br>toc: true<br>tags:</p>
<h2 id="前端面试题"><a href="#前端面试题" class="headerlink" title="- 前端面试题"></a>- 前端面试题</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>1.<strong>DOM操作</strong></p>
<pre><code class="bash">createElement 通过传入指定的一个标签名来创建一个元素，如果传入的标签名是一个未知的，则会创建一个自定义的标签
createTextNode createTextNode用来创建一个文本节点
<span class="built_in">clone</span>Node <span class="built_in">clone</span>Node是用来返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否复制子元素
createDocumentFragment createDocumentFragment方法用来创建一个DocumentFragment
appendChild 将指定的节点添加到调用该方法的节点的子元素的末尾
insertBefore insertBefore用来添加一个节点到一个参照节点之前
removeChild 删除指定的子节点并返回
replaceChild replaceChild用于使用一个节点替换另一个节点
document.getElementById 根据元素id返回元素，返回值是Element类型，如果不存在该元素，则返回null
document.getElementsByTagName 这个接口根据元素标签名获取元素，返回一个即时的HTMLCollection类型
document.getElementsByName getElementsByName主要是通过指定的name属性来获取元素，它返回一个即时的NodeList对象
document.getElementsByClassName 这个API是根据元素的class返回一个即时的HTMLCollection
document.querySelector和document.querySelectorAll 通过css选择器来查找元素
节点关系型api parentNode parentElement previousSibling previousElementSibling nextSibling nextElementSibling childNodes children firstNode lastNode hasChildNodes
元素属性型api <span class="built_in">set</span>Attribute getAttribute
元素样式型api 
window.getComputedStyle 用来获取应用到元素后的样式
getBoundingClientRect 用来返回元素的大小以及相对于浏览器可视窗口的位置
</code></pre>
<p>2.<strong>如何使用事件</strong></p>
<pre><code class="bash">HTML内连属性
DOM属性绑定
事件监听函数 addEventListener
移除事件监听 removeEventListener
模拟触发事件 dispatchEvent
自定义事件 Event、CustomEvent 和 dispatchEvent
事件顺序 捕获阶段-&gt;达到元素后-&gt;进入事件冒泡阶段
事件Event对象几个属性：<span class="built_in">type</span>(string)，target(node)，currentTarget(node)，bubbles(boolean),preventDefault (<span class="keyword">function</span>),stopPropagation (<span class="keyword">function</span>),stopImmediatePropagation (<span class="keyword">function</span>),cancelable (boolean),eventPhase (number)
</code></pre>
<p>3.<strong>XMLHttpRequest详解</strong></p>
<pre><code class="javascript"><span class="comment">//XMLHttpRequest发送的ajax请求代码：</span>
<span class="function"><span class="keyword">function</span> <span class="title">sendAjax</span>(<span class="params"></span>) </span>{
  <span class="comment">//构造表单数据</span>
  <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();
  formData.append(<span class="string">'username'</span>, <span class="string">'johndoe'</span>);
  formData.append(<span class="string">'id'</span>, <span class="number">123456</span>);
  <span class="comment">//创建xhr对象 </span>
  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();
  <span class="comment">//设置xhr请求的超时时间</span>
  xhr.timeout = <span class="number">3000</span>;
  <span class="comment">//设置响应返回的数据格式</span>
  xhr.responseType = <span class="string">"text"</span>;
  <span class="comment">//创建一个 post 请求，采用异步</span>
  xhr.open(<span class="string">'POST'</span>, <span class="string">'/server'</span>, <span class="literal">true</span>);
  <span class="comment">//注册相关事件回调处理函数</span>
  xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>{ 
    <span class="keyword">if</span>(<span class="keyword">this</span>.status == <span class="number">200</span>||<span class="keyword">this</span>.status == <span class="number">304</span>){
        alert(<span class="keyword">this</span>.responseText);
    }
  };
  xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>{ ... };
  xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>{ ... };
  xhr.upload.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>{ ... };

  <span class="comment">//发送数据</span>
  xhr.send(formData);
}
</code></pre>
<pre><code class="bash">XHR 对象的属性和方法
属性:
    readyState：HTTP 请求的状态
    responseText：响应体（不包括头部）
    responseXML：对请求的响应，解析为 XML 并作为 Document 对象返回
    status：由服务器返回的 HTTP 状态代码，如 200 表示成功
    statusText：这个属性用名称而不是数字指定了请求的 HTTP 的状态代码。也就是说，当状态为 200 的时候它是 <span class="string">"OK"</span>，当状态为 404 的时候它是 <span class="string">"Not Found"</span>
    responseType：返回的我们设置的数据类型（text，document，json，blob，arrayBuffer）
    timeout：设置请求的超时时间
方法:
    loadstart(): 调用xhr.send()方法后立即触发
    progress(): xhr.upload.onprogress在上传阶段(即xhr.send()之后，xhr.readystate=2之前)触发，每50ms触发一次；xhr.onprogress在下载阶段（即xhr.readystate=3时）触发，每50ms触发一次
    timeout: xhr.timeout不等于0，由请求开始即onloadstart开始算起，当到达xhr.timeout所设置时间请求还未结束即onloadend，则触发此事件
    load: 当请求成功完成时触发，此时xhr.readystate=4
    loadend: 当请求结束（包括请求成功和请求失败）时触发
    abort() : 取消当前响应，关闭连接并且结束任何未决的网络活动
    getAllResponseHeaders()：把 HTTP 响应头部作为未解析的字符串返回
    getResponseHeader()：返回指定的 HTTP 响应头部的值
    open(method,url[,async = <span class="literal">true</span>[,username = null, [,password = null]])：初始化 HTTP 请求参数，例如 URL 和 HTTP 方法，但是并不发送请求
    send()：发送 HTTP 请求，使用传递给 open() 方法的参数，以及传递给该方法的可选请求体
    <span class="built_in">set</span>RequestHeader()：向一个打开但未发送的请求设置或添加一个 HTTP 请求
    overrideMimeType()：返回的我们设置的数据类型

xhr事件：onreadystatechange 监听xhr返回时的事件
获取上传、下载的进度: onprogress事件
    上传触发的是xhr.upload对象的 onprogress事件
    下载触发的是xhr对象的onprogress事件
事件出发顺序：
    1.触发xhr.onreadystatechange(之后每次readyState变化时，都会触发一次)
    2.触发xhr.onloadstart
    //上传阶段开始：
    3.触发xhr.upload.onloadstart
    4.触发xhr.upload.onprogress
    5.触发xhr.upload.onload
    6.触发xhr.upload.onloadend
    //上传结束，下载阶段开始：
    7.触发xhr.onprogress
    8.触发xhr.onload
    9.触发xhr.onloadend
</code></pre>
<p>4.<strong>如何使用浮动元素，以及带来的问题和解决方案</strong></p>
<pre><code class="bash">浮动定义：浮动的框可以左右移动，直至它的外边缘遇到包含框或者另一个浮动框的边缘，通过设置<span class="built_in">float</span>属性实现
现象：正是因为浮动的这种特性，导致本属于普通流中的元素浮动之后，包含框内部由于不存在其他普通流元素了，也就表现出高度为0（高度塌陷）。在实际布局中，往往这并不是我们所希望的，所以需要闭合浮动元素，使其包含框表现出正常的高度
如何清除浮动：
    清除浮动：清除对应的单词是 clear，对应CSS中的属性是 clear：left | right | both | none
    闭合浮动：更确切的含义是使浮动元素闭合，从而减少浮动带来的影响
BFC的特性
    块级格式化上下文会阻止外边距叠加
    当两个相邻的块框在同一个块级格式化上下文中时，它们之间垂直方向的外边距会发生叠加。换句话说，如果这两个相邻的块框不属于同一个块级格式化上下文，那么它们的外边距就不会叠加。
    块级格式化上下文不会重叠浮动元素
    根据规定，一个块级格式化上下文的边框不能和它里面的元素的外边距重叠。这就意味着浏览器将会给块级格式化上下文创建隐式的外边距来阻止它和浮动元素的外边距叠加。由于这个原因，当给一个挨着浮动的块级格式化上下文添加负的外边距时将会不起作用（Webkit和IE6在这点上有一个问题——可以看这个测试用例）。
    块级格式化上下文通常可以包含浮动
如何触发BFC?
    <span class="built_in">float</span> 除了none以外的值
    overflow 除了visible 以外的值（hidden，auto，scroll ）
    display (table-cell，table-caption，inline-block)
    position（absolute，fixed）
    fieldset元素
BFC的几个用途
    1、BFC可以阻止垂直边距叠加问题
    2、BFC可以包含内部元素的浮动
    3、BFC可以阻止元素被浮动覆盖
    4、BFC可以决定清除浮动的范围
</code></pre>
<p>5.<strong>HTMLXHTML区别，如何选择</strong></p>
<pre><code class="bash">xhtml:
    1.所有的标记都都要闭合 
    2.所有标签的元素和属性的名字都必须使用小写 
    3.所有的XML标记都必须合理嵌套 
    4.所有的属性必须用引号（单或双）包括在HTML中，你可以不需要给属性值加引号，但是在XHTML中，它们必须被加引号
    5.把所有&lt;和&amp;特殊符号用编码表示任何小于号（&lt;），不是标签的一部分，都必须被编码为&amp; l t ; 任何大于号（&gt;），不是标签的一部分，都必须被编码为&amp; g t ; 任何与号（&amp;），不是实体的一部分的，都必须被编码为&amp; a m p
    6.给所有属性赋一个值 
    7.不要在注释内容中使<span class="string">"- -"</span> 
    8.图片必须有说明文字 每个图片标签都必须有ALT说明文字
</code></pre>
<p>6.<strong>JSON作用，用途，设计结构</strong></p>
<pre><code class="bash">JSON API 是数据交互规范，用以定义客户端如何获取与修改资源，以及服务器如何响应对应请求
JSON API设计用来最小化请求的数量，以及客户端与服务器间传输的数据量。在高效实现的同时，无需牺牲可读性、灵活性和可发现性
JSON API需要使用JSON API媒体类型(application/vnd.api+json) 进行数据交互
JSON API服务器支持通过GET方法获取资源。而且必须独立实现HTTP POST, PUT和DELETE方法的请求响应，以支持资源的创建、更新和删除
</code></pre>
