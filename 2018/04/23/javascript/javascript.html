<hr>
<p>title: 你不知道javascript（上卷）知识点总结<br>date: 2017-05-17 19:24:32<br>categories: 前端知识点总结<br>toc: true<br>tags:</p>
<ul>
<li>javascript</li>
<li>你不知道的javascript</li>
</ul>
<hr>
<h3 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ol>
<li>编译的三步骤:分词／词法分析，解析／语法分析，代码生成</li>
<li>javascript编译器工作过程:1.在当前作用域中声明一个变量（如果之前没有声明）；2.在运行时引擎会在作用域中查找该变量，如果能够找到变量就会对它赋值</li>
<li>编译器查找变量的方法是通过LHS查询和RHS查询，当变量出现在赋值操作的左侧时执行LHS查询，当赋值出现在右侧时进行的是RHS查询</li>
<li>当一个块或函数嵌套在另一个块或函数时，就发生了作用域的嵌套，因此，在当前作用域中无法找到某个变量时，引擎会在外层作用域中查找，直到找到该变量，或抵达最外层作用域停止</li>
<li>在非严格模式下，如果通过RHS查询无法查询到变量，但是通过LHS查询时如果不存在这个变量会自动声明这个变量，在严格模式下两者查询模式都是不行的 </li>
</ol>
<h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><ol>
<li>作用域共有两种工作模型:1.词法作用域；2.动态作用域</li>
<li>词法作用域就是定义在词法阶段的作用域</li>
<li>欺骗词法的两种机制(非常影响性能):<br>1.eval函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码，严格模式的声明是无法修改所在的作用域    <pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>)</span>{
<span class="built_in">eval</span>(str);  <span class="comment">//欺骗</span>
<span class="built_in">console</span>.log(a, b);
}
<span class="keyword">var</span> b = <span class="number">2</span>;
foo(<span class="string">"var b = 3;"</span>, <span class="number">1</span>) <span class="comment">//1,3</span>
</code></pre>
2.with关键字通常被当作重复引用同一个对象中的多个属性的快捷方式<pre><code class="javascript"><span class="keyword">var</span> obj = {
    <span class="attr">a</span>: <span class="number">1</span>,
    <span class="attr">b</span>: <span class="number">2</span>,
    <span class="attr">c</span>: <span class="number">3</span>
}
obj.a = <span class="number">2</span>;
obj.b = <span class="number">3</span>;
obj.c = <span class="number">4</span>;
<span class="comment">//简单的快捷方式</span>
<span class="keyword">with</span>(obj){
    a = <span class="number">3</span>;
    b = <span class="number">4</span>;
    c = <span class="number">5</span>;
}
</code></pre>
</li>
</ol>
<h4 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h4><ol>
<li>函数会被当作函数表达式而不是一个标准的函数声明来处理</li>
<li>width，try／catch中的catch都是块作用域中例子</li>
</ol>
<h4 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h4><ol>
<li>包含变量和函数在内的所有声明都会在任何代码被执行前首先被处理</li>
<li>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升该拜年了代码的顺序，会造成严重的破坏</li>
<li>函数声明会被提升，但是函数表达式却不会被提升</li>
<li>函数会首先被提升，然后才是变量</li>
<li>代码执行会经过两个阶段任务:1.编译阶段的人物；2.执行阶段任务</li>
</ol>
<h4 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h4><ol>
<li>无论通过任何手段将内部函数传递到所在的词法作用域以外，他都会持有对原始定义作用域的引用，无论在何处执行这个函数都是使用闭包</li>
<li>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包</li>
</ol>
<h4 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h4><ol>
<li>词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的，词法作用域关注函数在何处声明，动态作用域关注函数从何处调用</li>
</ol>
<h3 id="this和对象原型"><a href="#this和对象原型" class="headerlink" title="this和对象原型"></a>this和对象原型</h3><h4 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h4><ol>
<li>arguments.callee目前唯一一种从匿名函数对象内部引用自身的方法</li>
<li>this是在运行时调用的，并不是在编写时绑定的。这个记录会包含函数在哪里被调用，函数的调用方法，传入参数等信息。this就是记录的其中一个属性，会在函数执行的过程中用到</li>
<li>this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用</li>
</ol>
<h4 id="this全面解析"><a href="#this全面解析" class="headerlink" title="this全面解析"></a>this全面解析</h4><ol>
<li>调用位置:函数在代码中被调用的位置，而不是声明的位置</li>
<li>查看绑定规则:1.默认绑定；2.隐式绑定；3.显式绑定（call和apply）；4.new绑定</li>
<li>四种绑定的优先级:new绑定&gt;显示绑定&gt;隐式绑定&gt;默认绑定</li>
<li>将null和undefined通过call或apply传入函数实际等价于默认绑定</li>
<li>软绑定➡如果给默认绑定指定一个全局对象和undefined以外的值，那就可以和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改this的能力</li>
<li></li>
</ol>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ol>
<li>对象可以通过声明形式和构造形式定义</li>
<li>六种类型:string，number，boolean，null，undefined，object</li>
<li>对象子类型:String，Number，Boolean，Object，Function，Array，Date，RegExp，Error</li>
<li>在对象中属性名永远都是字符串，如果使用了string以外的值，那么它首先会转化为字符串</li>
<li>函数和方法本质是等价的，唯一不同的是方法里面使用的this会隐式指向对象</li>
<li>浅复制即对值的引用，深复制会复制其相关联的元素</li>
<li>object.assign实现浅复制</li>
<li>通过object.defineProperty来添加一个新属性或者修改一个已有的属性，并对特性进行设置     <pre><code class="javascript"><span class="keyword">var</span> myObj = {};
<span class="built_in">Object</span>.defineProperty(myObj, <span class="string">"a"</span>, {
    <span class="attr">value</span>: <span class="number">2</span>,
    <span class="attr">writable</span>: <span class="literal">true</span>,
    <span class="attr">configurable</span>: <span class="literal">true</span>,
    <span class="attr">enumerable</span>: <span class="literal">true</span>
})
</code></pre>
</li>
<li>禁用扩展 Object.preventExtensions</li>
<li>密封 Object.seal 不可重新配置也不可删除任何现有属性</li>
<li>冻结 Object.freeze 对象上最高级别的不可用性</li>
<li>Object.hasOwnProperty检查属性是否存在对象中</li>
<li>Object.propertyIsEnumerable检查给定属性名是否直接存在于对象中，Object.keys返回可枚举属性的数组，Object.getOwnPropertyNames 返回一个数组，包含所有属性</li>
<li>forEach遍历数组的所有值，并忽略回调函数的返回值</li>
<li>every（）和some（）中特殊的返回值类似for里面的break</li>
<li>for…of..会寻找内置或者自定义的@@iterator对象并调用它的next（）方法来遍历数据值</li>
</ol>
<h4 id="混合对象“类”"><a href="#混合对象“类”" class="headerlink" title="混合对象“类”"></a>混合对象“类”</h4><ol>
<li>面向类的设计模式：实例化，继承，多台</li>
<li>多态是说父类的通用行为可以被子类更特殊的行为重写</li>
<li><p>类实例由一个特殊的方法构造，成为构造函数，这个方法的任务就是初始化实例需要的所有信息  </p>
<pre><code class="javascript"><span class="class"><span class="keyword">class</span> <span class="title">CoolGuy</span> </span>{
    specialTrick = nothing;
    CoolGuy(trick) {
        specialTrick = trick;
    }
    showOff(){
        output(<span class="string">"Here's my trick: "</span>, specialTrick)
    }
}

Joe = <span class="keyword">new</span> CoolGuy(<span class="string">"jumping rope"</span>);
Joe.showOff();
</code></pre>
</li>
<li>javascript本身不提供多重继承，但是可以通过各种办法来实现多重继承</li>
<li>模拟类的复制：显示和隐式</li>
<li>显示混入实现类似于extend <pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params"> sourceObj, targetObj</span>) </span>{
    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> sourceObj){
        <span class="keyword">if</span>(!(key <span class="keyword">in</span> targetObj)){
            targetObj[key] = sourceObj[key];
        }
    }
    <span class="keyword">return</span> targetObj;
}
<span class="keyword">var</span> Vehicle = {
    <span class="attr">engine</span>: <span class="number">1</span>,
    <span class="attr">ignition</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="built_in">console</span>.log(<span class="string">"Turning on my engine"</span>);
    },
    <span class="attr">drive</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="keyword">this</span>.ignition();
        <span class="built_in">console</span>.log(<span class="string">"Steering and moving forward"</span>);
    }
};
<span class="keyword">var</span> Car = mixin(Vehicle, {
    <span class="attr">wheels</span>: <span class="number">4</span>,
    <span class="attr">drive</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        Vehicle.drive.call(<span class="keyword">this</span>);
        <span class="built_in">console</span>.log(<span class="string">"Rolling on all"</span> + <span class="keyword">this</span>.wheels + <span class="string">"whells"</span>);
    }
});
</code></pre>
</li>
<li><p>隐式混入    </p>
<pre><code class="javascript"><span class="class"><span class="keyword">class</span> <span class="title">CoolGuy</span> </span>{
    specialTrick = nothing;
    CoolGuy(trick) {
        specialTrick = trick;
    }
    showOff(){
        output(<span class="string">"Here's my trick: "</span>, specialTrick)
    }
}

Joe = <span class="keyword">new</span> CoolGuy(<span class="string">"jumping rope"</span>);
Joe.showOff();
</code></pre>
</li>
<li>javascript本身不提供多重继承，但是可以通过各种办法来实现多重继承</li>
<li>模拟类的复制：显示和隐式</li>
<li>显示混入实现类似于extend <pre><code class="javascript"><span class="keyword">var</span> Something = {
   <span class="attr">cool</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
       <span class="keyword">this</span>.greeting = <span class="string">"hello, world"</span>;
       <span class="keyword">this</span>.count = <span class="keyword">this</span>.count?<span class="keyword">this</span>.count+<span class="number">1</span>:<span class="number">1</span>;
   }
}
Something.cool();
Something.greeting;
Something.count;
<span class="keyword">var</span> Another = {
   <span class="attr">cool</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
       Something.cool.call(<span class="keyword">this</span>);
   }
}
Another.cool();
Another.greeting;
Another.count;
</code></pre>
</li>
<li>类意味着复制</li>
</ol>
<h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><ol>
<li>javascript中的对象有一个特殊的[[prototype]]内置属性，其实就是对于其他对象的引用</li>
<li>所有的普通[[prototype]]链都会指向内置的object.prototype</li>
<li>所有的函数类默认都会拥有一个名为prototype的公有并且不可枚举的属性，它指向另一个对象</li>
<li>javascript不能创建一个类的多个实例，只能创建多个对象，他们关联到同一个对象</li>
<li>new会劫持所有普通函数并且用构造对象的形式来调用它</li>
</ol>
<h4 id="行为委托"><a href="#行为委托" class="headerlink" title="行为委托"></a>行为委托</h4><ol>
<li>如果在第一个对象上没有找到需要的属性或者方法引用，引擎就会继续在关联的对象上进行查找，如果后者还是没找到则会继续查找他的prototype，这一系列对象的链接称为“原型链”</li>
<li>委托行为意味着某些对象在找不到属性或者方法引用时会把这个请求委托给另一个对象</li>
<li>无法在两个或者两个以上相互为多的对象之间创建循环委托</li>
<li>Object.create()方法使用指定的原型对象和其属性创建了一个新的对象</li>
</ol>
