<hr>
<p>title: 堆栈存储区别及常用算法总结<br>date: 2017-05-22 22:40:47<br>categories: 算法<br>toc: true<br>tags:</p>
<ul>
<li>stack heap</li>
<li>DP DFS BFS</li>
</ul>
<hr>
<h3 id="堆栈之间的区别"><a href="#堆栈之间的区别" class="headerlink" title="堆栈之间的区别"></a>堆栈之间的区别</h3><ol>
<li>栈区（stack）由编译器自动分配释放，存放函数的参数值，局部变量的值等 其操作方式类似于数据结构中的栈</li>
<li>堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收 注意它与数据结构中的堆是两回事，分配方式倒是类似于链表</li>
<li>申请后系统的响应: 只要栈的剩余空间大于所申·请空间，系统将为程序提供内存，否则将报异常提示栈溢出;首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时,会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中</li>
<li>申请大小的限制 : 栈获得的空间较小,堆获得的空间比较灵活，也比较大</li>
<li>申请效率的比较: 栈由系统自动分配，速度较快,但程序员是无法控制的;堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便;</li>
<li>堆和栈中的存储内容 : 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数;一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排;</li>
<li>存取效率的比较: 在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快</li>
</ol>
<h3 id="DP算法-Dynamic-programming"><a href="#DP算法-Dynamic-programming" class="headerlink" title="DP算法(Dynamic programming)"></a>DP算法(Dynamic programming)</h3><pre><code class="bash">1.动态规划的本质，是对问题状态的定义和状态转移方程的定义
2.将问题发展到各个阶段时所处于的各种客观情况用不同的状态,而且状态的选择要满足无后效性,即对后面的状态无任何影响
3.上述状态定义好之后，状态和状态之间的关系式，就叫做状态转移方程
4.典型例子: 01背包问题,装配线调度
</code></pre>
<h3 id="DFS算法-Depth-First-Search"><a href="#DFS算法-Depth-First-Search" class="headerlink" title="DFS算法(Depth-First-Search)"></a>DFS算法(Depth-First-Search)</h3><pre><code class="bash">深度优先搜索在搜索过程中访问某个顶点后，需要递归地访问此顶点的所有未访问过的相邻顶点。
初始条件下所有节点为白色，选择一个作为起始顶点，按照如下步骤遍历：
a. 选择起始顶点涂成灰色，表示还未访问
b. 从该顶点的邻接顶点中选择一个，继续这个过程（即再寻找邻接结点的邻接结点），一直深入下去，直到一个顶点没有邻接结点了，涂黑它，表示访问过了
c. 回溯到这个涂黑顶点的上一层顶点，再找这个上一层顶点的其余邻接结点，继续如上操作，如果所有邻接结点往下都访问过了，就把自己涂黑，再回溯到更上一层。
d. 上一层继续做如上操作，知道所有顶点都访问过。

核心是通过栈的方式实现
</code></pre>
<h3 id="BFS算法-Breadth-First-Search"><a href="#BFS算法-Breadth-First-Search" class="headerlink" title="BFS算法(Breadth-First-Search)"></a>BFS算法(Breadth-First-Search)</h3><pre><code class="bash">广度优先搜索在进一步遍历图中顶点之前，先访问当前顶点的所有邻接结点。
a .首先选择一个顶点作为起始结点，并将其染成灰色，其余结点为白色。
b. 将起始结点放入队列中。
c. 从队列首部选出一个顶点，并找出所有与之邻接的结点，将找到的邻接结点放入队列尾部，将已访问过结点涂成黑色，没访问过的结点是白色。如果顶点的颜色是灰色，表示已经发现并且放入了队列，如果顶点的颜色是白色，表示还没有发现
d. 按照同样的方法处理队列中的下一个结点。
基本就是出队的顶点变成黑色，在队列里的是灰色，还没入队的是白色

核心是通过队列的方式实现
</code></pre>
<h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><pre><code class="bahs">核心思想: 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并
</code></pre>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><pre><code class="bash">核心思想: 在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）
</code></pre>
<h3 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h3><pre><code class="bash">核心思想: 所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索
</code></pre>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><pre><code class="bash">核心思想: 在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解
</code></pre>
