<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端那点事</title>
  <subtitle>记录前端笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lzm420241.github.io/"/>
  <updated>2018-07-15T01:18:26.000Z</updated>
  <id>https://lzm420241.github.io/</id>
  
  <author>
    <name>Zhiming Li</name>
    <email>lzm420241@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tensorflow安装</title>
    <link href="https://lzm420241.github.io/2018/07/15/AI/tensorflow%E5%AE%89%E8%A3%85/"/>
    <id>https://lzm420241.github.io/2018/07/15/AI/tensorflow安装/</id>
    <published>2018-07-15T01:13:29.000Z</published>
    <updated>2018-07-15T01:18:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装python"><a href="#安装python" class="headerlink" title="安装python"></a>安装python</h3><h3 id="安装tensorflow"><a href="#安装tensorflow" class="headerlink" title="安装tensorflow"></a>安装tensorflow</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装python&quot;&gt;&lt;a href=&quot;#安装python&quot; class=&quot;headerlink&quot; title=&quot;安装python&quot;&gt;&lt;/a&gt;安装python&lt;/h3&gt;&lt;h3 id=&quot;安装tensorflow&quot;&gt;&lt;a href=&quot;#安装tensorflow&quot; cla
    
    </summary>
    
      <category term="AI" scheme="https://lzm420241.github.io/categories/AI/"/>
    
    
      <category term="tensorflow" scheme="https://lzm420241.github.io/tags/tensorflow/"/>
    
      <category term="python" scheme="https://lzm420241.github.io/tags/python/"/>
    
      <category term="Mac 环境" scheme="https://lzm420241.github.io/tags/Mac-%E7%8E%AF%E5%A2%83/"/>
    
      <category term="docker" scheme="https://lzm420241.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://lzm420241.github.io/2018/05/21/Babel%20%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C/"/>
    <id>https://lzm420241.github.io/2018/05/21/Babel 用户手册/</id>
    <published>2018-05-21T06:35:29.000Z</published>
    <updated>2018-05-21T06:35:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Babel-用户手册"><a href="#Babel-用户手册" class="headerlink" title="Babel 用户手册"></a>Babel 用户手册</h1><p>这本手册涵盖了关于 <a href="https://babeljs.io" target="_blank" rel="external">Babel</a> 的使用及其相关工具的内容。</p>
<p><a href="http://creativecommons.org/licenses/by/4.0/" target="_blank" rel="external"><img src="https://licensebuttons.net/l/by/4.0/80x15.png" alt="cc-by-4.0"></a></p>
<p>这本手册提供了多种语言的版本，查看 <a href="/README.md">自述文件</a> 里的完整列表。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#toc-introduction">介绍</a></li>
<li><a href="#toc-setting-up-babel">安装 Babel</a> <ul>
<li><a href="#toc-babel-cli"><code>babel-cli</code></a></li>
<li><a href="#toc-running-babel-cli-from-within-a-project">在项目内运行 Babel CLI</a></li>
<li><a href="#toc-babel-register"><code>babel-register</code></a></li>
<li><a href="#toc-babel-node"><code>babel-node</code></a></li>
<li><a href="#toc-babel-core"><code>babel-core</code></a></li>
</ul>
</li>
<li><a href="#toc-configuring-babel">配置 Babel</a> <ul>
<li><a href="#toc-babelrc"><code>.babelrc</code></a></li>
<li><a href="#toc-babel-preset-es2015"><code>babel-preset-es2015</code></a></li>
<li><a href="#toc-babel-preset-react"><code>babel-preset-react</code></a></li>
<li><a href="#toc-babel-preset-stage-x"><code>babel-preset-stage-x</code></a></li>
</ul>
</li>
<li><a href="#toc-executing-babel-generated-code">执行 Babel 生成的代码</a> <ul>
<li><a href="#toc-babel-polyfill"><code>babel-polyfill</code></a></li>
<li><a href="#toc-babel-runtime"><code>babel-runtime</code></a></li>
</ul>
</li>
<li><a href="#toc-configuring-babel-advanced">配置 Babel（进阶）</a> <ul>
<li><a href="#toc-manually-specifying-plugins">手动指定插件</a></li>
<li><a href="#toc-plugin-options">插件选项</a></li>
<li><a href="#toc-customizing-babel-based-on-environment">基于环境自定义 Babel</a></li>
<li><a href="#toc-making-your-own-preset">制作你自己的预设（preset）</a></li>
</ul>
</li>
<li><a href="#toc-babel-and-other-tools">Babel 和其他工具</a> <ul>
<li><a href="#toc-static-analysis-tools">静态分析工具</a></li>
<li><a href="#toc-linting">语法检查（Linting）</a></li>
<li><a href="#toc-code-style">代码风格</a></li>
<li><a href="#toc-documentation">文档</a></li>
<li><a href="#toc-frameworks">框架</a></li>
<li><a href="#toc-react">React</a></li>
<li><a href="#toc-text-editors-and-ides">文本编辑器和 IDEs（集成开发环境）</a></li>
</ul>
</li>
<li><a href="#toc-babel-support">Babel 支持</a> <ul>
<li><a href="#toc-babel-forum">Babel 论坛</a></li>
<li><a href="#toc-babel-chat">Babel 聊天</a></li>
<li><a href="#toc-babel-issues">Babel 问题</a></li>
<li><a href="#toc-creating-an-awesome-babel-bug-report">创建漂亮的 Babel 错误报告</a></li>
</ul>
</li>
</ul>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><a id="toc-introduction"></a>介绍</h1><p>Babel 是一个通用的多用途 JavaScript 编译器。通过 Babel 你可以使用（并创建）下一代的 JavaScript，以及下一代的 JavaScript 工具。</p>
<p>作为一种语言，JavaScript 在不断发展，新的标准／提案和新的特性层出不穷。 在得到广泛普及之前，Babel 能够让你提前（甚至数年）使用它们。</p>
<p>Babel 把用最新标准编写的 JavaScript 代码向下编译成可以在今天随处可用的版本。 这一过程叫做“源码到源码”编译， 也被称为转换编译（transpiling，是一个自造合成词，即转换＋编译。以下也简称为转译）。</p>
<p>例如，Babel 能够将新的 ES2015 箭头函数语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</div></pre></td></tr></table></figure>
<p>转译为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> square = <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>不过 Babel 的用途并不止于此，它支持语法扩展，能支持像 React 所用的 JSX 语法，同时还支持用于静态类型检查的流式语法（Flow Syntax）。</p>
<p>更重要的是，Babel 的一切都是简单的插件，谁都可以创建自己的插件，利用 Babel 的全部威力去做任何事情。</p>
<p><em>再进一步</em>，Babel 自身被分解成了数个核心模块，任何人都可以利用它们来创建下一代的 JavaScript 工具。</p>
<p>已经有很多人都这样做了，围绕着 Babel 涌现出了非常大规模和多样化的生态系统。 在这本手册中，我将介绍如何使用 Babel 的内建工具以及一些来自于社区的非常有用的东西。</p>
<blockquote>
<p><strong><em>在 Twitter 上关注 <a href="https://twitter.com/thejameskyle" target="_blank" rel="external">@thejameskyle</a>，第一时间获取更新。</em></strong></p>
</blockquote>
<hr>
<h1 id="安装-Babel"><a href="#安装-Babel" class="headerlink" title="安装 Babel"></a><a id="toc-setting-up-babel"></a>安装 Babel</h1><p>由于 JavaScript 社区没有统一的构建工具、框架、平台等等，因此 Babel 正式集成了对所有主流工具的支持。 从 Gulp 到 Browserify，从 Ember 到 Meteor，不管你的环境设置如何，Babel 都有正式的集成支持。</p>
<p>本手册的目的主要是介绍 Babel 内建方式的安装，不过你可以访问交互式的<a href="http://babeljs.io/docs/setup" target="_blank" rel="external">安装页面</a>来查看其它的整合方式。</p>
<blockquote>
<p><strong>注意：</strong> 本手册将涉及到一些命令行工具如 <code>node</code> 和 <code>npm</code>。在继续阅读之前请确保你已经熟悉这些工具了。</p>
</blockquote>
<h2 id="babel-cli"><a href="#babel-cli" class="headerlink" title="babel-cli"></a><a id="toc-babel-cli"></a><code>babel-cli</code></h2><p>Babel 的 CLI 是一种在命令行下使用 Babel 编译文件的简单方法。</p>
<p>让我们先全局安装它来学习基础知识。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --global babel-cli</div></pre></td></tr></table></figure>
<p>我们可以这样来编译我们的第一个文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ babel my-file.js</div></pre></td></tr></table></figure>
<p>这将把编译后的结果直接输出至终端。使用 <code>--out-file</code> 或着 <code>-o</code> 可以将结果写入到指定的文件。.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ babel example.js --out-file compiled.js</div><div class="line"><span class="comment"># 或</span></div><div class="line">$ babel example.js -o compiled.js</div></pre></td></tr></table></figure>
<p>如果我们想要把一个目录整个编译成一个新的目录，可以使用 <code>--out-dir</code> 或者 <code>-d</code>。.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ babel src --out-dir lib</div><div class="line"><span class="comment"># 或</span></div><div class="line">$ babel src <span class="_">-d</span> lib</div></pre></td></tr></table></figure>
<h3 id="在项目内运行-Babel-CLI"><a href="#在项目内运行-Babel-CLI" class="headerlink" title="在项目内运行 Babel CLI"></a><a id="toc-running-babel-cli-from-within-a-project"></a>在项目内运行 Babel CLI</h3><p>尽管你<em>可以</em>把 Babel CLI 全局安装在你的机器上，但是按项目逐个安装在<strong>本地</strong>会更好。</p>
<p>有两个主要的原因。</p>
<ol>
<li>在同一台机器上的不同项目或许会依赖不同版本的 Babel 并允许你有选择的更新。</li>
<li>这意味着你对工作环境没有隐式依赖，这让你的项目有很好的可移植性并且易于安装。</li>
</ol>
<p>要在（项目）本地安装 Babel CLI 可以运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev babel-cli</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>因为全局运行 Babel 通常不是什么好习惯所以如果你想要卸载全局安装的 Babel 的话，可以运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm uninstall --global babel-cli</div></pre></td></tr></table></figure>
</blockquote>
<p>安装完成后，你的 <code>package.json</code> 应该如下所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"my-project"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</div><div class="line">  <span class="attr">"devDependencies"</span>: &#123;</div><div class="line">    <span class="attr">"babel-cli"</span>: <span class="string">"^6.0.0"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，我们不直接从命令行运行 Babel 了，取而代之我们将把运行命令写在 <strong>npm scripts</strong> 里，这样可以使用 Babel 的本地版本。</p>
<p>只需将 <code>&quot;scripts&quot;</code> 字段添加到你的 <code>package.json</code> 文件内并且把 babel 命令写成 <code>build</code> 字段。.</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  &#123;</div><div class="line">    "name": "my-project",</div><div class="line">    "version": "1.0.0",</div><div class="line"><span class="addition">+   "scripts": &#123;</span></div><div class="line"><span class="addition">+     "build": "babel src -d lib"</span></div><div class="line"><span class="addition">+   &#125;,</span></div><div class="line">    "devDependencies": &#123;</div><div class="line">      "babel-cli": "^6.0.0"</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>现在可以在终端里运行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run build</div></pre></td></tr></table></figure>
<p>这将以与之前同样的方式运行 Babel，但这一次我们使用的是本地副本。</p>
<h2 id="babel-register"><a href="#babel-register" class="headerlink" title="babel-register"></a><a id="toc-babel-register"></a><code>babel-register</code></h2><p>下一个常用的运行 Babel 的方法是通过 <code>babel-register</code>。这种方法只需要引入文件就可以运行 Babel，或许能更好地融入你的项目设置。</p>
<p>但请注意这种方法并不适合正式产品环境使用。 直接部署用此方式编译的代码不是好的做法。 在部署之前预先编译会更好。 不过用在构建脚本或是其他本地运行的脚本中是非常合适的。</p>
<p>让我们先在项目中创建 <code>index.js</code> 文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"Hello world!"</span>);</div></pre></td></tr></table></figure>
<p>如果我们用 <code>node index.js</code> 来运行它是不会使用 Babel 来编译的。所以我们需要设置 <code>babel-register</code>。.</p>
<p>首先安装 <code>babel-register</code>。.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev babel-register</div></pre></td></tr></table></figure>
<p>接着，在项目中创建 <code>register.js</code> 文件并添加如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">"babel-register"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./index.js"</span>);</div></pre></td></tr></table></figure>
<p>这样做可以把 Babel <em>注册</em>到 Node 的模块系统中并开始编译其中 <code>require</code> 的所有文件。</p>
<p>现在我们可以使用 <code>register.js</code> 来代替 <code>node index.js</code> 来运行了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node register.js</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>你不能在你要编译的文件内同时注册 Babel，因为 node 会在 Babel 编译它之前就将它执行了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">"babel-register"</span>);</div><div class="line"><span class="comment">// 未编译的：</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Hello world!"</span>);</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="babel-node"><a href="#babel-node" class="headerlink" title="babel-node"></a><a id="toc-babel-node"></a><code>babel-node</code></h2><p>如果你要用 <code>node</code> CLI 来运行代码，那么整合 Babel 最简单的方式就是使用 <code>babel-node</code> CLI，它是 <code>node</code> CLI 的替代品。</p>
<p>但请注意这种方法并不适合正式产品环境使用。 直接部署用此方式编译的代码不是好的做法。 在部署之前预先编译会更好。 不过用在构建脚本或是其他本地运行的脚本中是非常合适的。</p>
<p>首先确保 <code>babel-cli</code> 已经安装了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev babel-cli</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意:</strong> 如果您想知道我们为什么要在本地安装，请阅读 上面<a href="#toc-running-babel-cli-from-within-a-project">在项目内运行Babel CLI</a>的部分。</p>
</blockquote>
<p>然后用 <code>babel-node</code> 来替代 <code>node</code> 运行所有的代码 。.</p>
<p>如果用 npm <code>scripts</code> 的话只需要这样做：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  &#123;</div><div class="line">    "scripts": &#123;</div><div class="line"><span class="deletion">-     "script-name": "node script.js"</span></div><div class="line"><span class="addition">+     "script-name": "babel-node script.js"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>要不然的话你需要写全 <code>babel-node</code> 的路径。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="deletion">- node script.js</span></div><div class="line"><span class="addition">+ ./node_modules/.bin/babel-node script.js</span></div></pre></td></tr></table></figure>
<blockquote>
<p>提示：你可以使用 <a href="https://www.npmjs.com/package/npm-run" target="_blank" rel="external"><code>npm-run</code></a>。.</p>
</blockquote>
<h2 id="babel-core"><a href="#babel-core" class="headerlink" title="babel-core"></a><a id="toc-babel-core"></a><code>babel-core</code></h2><p>如果你需要以编程的方式来使用 Babel，可以使用 <code>babel-core</code> 这个包。</p>
<p>首先安装 <code>babel-core</code>。.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install babel-core</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">"babel-core"</span>);</div></pre></td></tr></table></figure>
<p>字符串形式的 JavaScript 代码可以直接使用 <code>babel.transform</code> 来编译。.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">babel.transform(<span class="string">"code();"</span>, options);</div><div class="line"><span class="comment">// =&gt; &#123; code, map, ast &#125;</span></div></pre></td></tr></table></figure>
<p>如果是文件的话，可以使用异步 api：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">babel.transformFile(<span class="string">"filename.js"</span>, options, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line">  result; <span class="comment">// =&gt; &#123; code, map, ast &#125;</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>或者是同步 api：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">babel.transformFileSync(<span class="string">"filename.js"</span>, options);</div><div class="line"><span class="comment">// =&gt; &#123; code, map, ast &#125;</span></div></pre></td></tr></table></figure>
<p>要是已经有一个 Babel AST（抽象语法树）了就可以直接从 AST 进行转换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">babel.transformFromAst(ast, code, options);</div><div class="line"><span class="comment">// =&gt; &#123; code, map, ast &#125;</span></div></pre></td></tr></table></figure>
<p>对于上述所有方法，<code>options</code> 指的都是 <a href="http://babeljs.io/docs/usage/options/" target="_blank" rel="external">http://babeljs.io/docs/usage/options/</a></p>
<hr>
<h1 id="配置-Babel"><a href="#配置-Babel" class="headerlink" title="配置 Babel"></a><a id="toc-configuring-babel"></a>配置 Babel</h1><p>你或许已经注意到了，目前为止通过运行 Babel 自己我们并没能“翻译”代码，而仅仅是把代码从一处拷贝到了另一处。</p>
<p>这是因为我们还没告诉 Babel 要做什么。</p>
<blockquote>
<p>由于 Babel 是一个可以用各种花样去使用的通用编译器，因此默认情况下它反而什么都不做。你必须明确地告诉 Babel 应该要做什么。</p>
</blockquote>
<p>你可以通过安装<strong>插件（plugins）</strong>或<strong>预设（presets，也就是一组插件）</strong>来指示 Babel 去做什么事情。</p>
<h2 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a><a id="toc-babelrc"></a><code>.babelrc</code></h2><p>在我们告诉 Babel 该做什么之前，我们需要创建一个配置文件。你需要做的就是在项目的根路径下创建 <code>.babelrc</code> 文件。然后输入以下内容作为开始：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"presets"</span>: [],</div><div class="line">  <span class="string">"plugins"</span>: []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个文件就是用来让 Babel 做你要它做的事情的配置文件。</p>
<blockquote>
<p><strong>注意：</strong>尽管你也可以用其他方式给 Babel 传递选项，但 <code>.babelrc</code> 文件是约定也是最好的方式。</p>
</blockquote>
<h2 id="babel-preset-es2015"><a href="#babel-preset-es2015" class="headerlink" title="babel-preset-es2015"></a><a id="toc-babel-preset-es2015"></a><code>babel-preset-es2015</code></h2><p>我们先从让 Babel 把 ES2015（最新版本的 JavaScript 标准，也叫做 ES6）编译成 ES5（现今在大多数 JavaScript 环境下可用的版本）开始吧。</p>
<p>我们需要安装 “es2015” Babel 预设：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev babel-preset-es2015</div></pre></td></tr></table></figure>
<p>我们修改 <code>.babelrc</code> 来包含这个预设。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  &#123;</div><div class="line">    "presets": [</div><div class="line"><span class="addition">+     "es2015"</span></div><div class="line">    ],</div><div class="line">    "plugins": []</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="babel-preset-react"><a href="#babel-preset-react" class="headerlink" title="babel-preset-react"></a><a id="toc-babel-preset-react"></a><code>babel-preset-react</code></h2><p>设置 React 一样容易。只需要安装这个预设：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev babel-preset-react</div></pre></td></tr></table></figure>
<p>然后在 <code>.babelrc</code> 文件里补充：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  &#123;</div><div class="line">    "presets": [</div><div class="line">      "es2015",</div><div class="line"><span class="addition">+     "react"</span></div><div class="line">    ],</div><div class="line">    "plugins": []</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="babel-preset-stage-x"><a href="#babel-preset-stage-x" class="headerlink" title="babel-preset-stage-x"></a><a id="toc-babel-preset-stage-x"></a><code>babel-preset-stage-x</code></h2><p>JavaScript 还有一些提案，正在积极通过 TC39（ECMAScript 标准背后的技术委员会）的流程成为标准的一部分。</p>
<p>这个流程分为 5（0－4）个阶段。 随着提案得到越多的关注就越有可能被标准采纳，于是他们就继续通过各个阶段，最终在阶段 4 被标准正式采纳。</p>
<p>以下是4 个不同阶段的（打包的）预设：</p>
<ul>
<li><code>babel-preset-stage-0</code></li>
<li><code>babel-preset-stage-1</code></li>
<li><code>babel-preset-stage-2</code></li>
<li><code>babel-preset-stage-3</code></li>
</ul>
<blockquote>
<p>注意 stage-4 预设是不存在的因为它就是上面的 <code>es2015</code> 预设。</p>
</blockquote>
<p>以上每种预设都依赖于紧随的后期阶段预设。例如，<code>babel-preset-stage-1</code> 依赖 <code>babel-preset-stage-2</code>，后者又依赖 <code>babel-preset-stage-3</code>。.</p>
<p>使用的时候只需要安装你想要的阶段就可以了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev babel-preset-stage-2</div></pre></td></tr></table></figure>
<p>然后添加进你的 <code>.babelrc</code> 配置文件。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  &#123;</div><div class="line">    "presets": [</div><div class="line">      "es2015",</div><div class="line">      "react",</div><div class="line"><span class="addition">+     "stage-2"</span></div><div class="line">    ],</div><div class="line">    "plugins": []</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="执行-Babel-生成的代码"><a href="#执行-Babel-生成的代码" class="headerlink" title="执行 Babel 生成的代码"></a><a id="toc-executing-babel-generated-code"></a>执行 Babel 生成的代码</h1><p>即便你已经用 Babel 编译了你的代码，但这还不算完。</p>
<h2 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="babel-polyfill"></a><a id="toc-babel-polyfill"></a><code>babel-polyfill</code></h2><p>Babel 几乎可以编译所有时新的 JavaScript 语法，但对于 APIs 来说却并非如此。</p>
<p>比方说，下列含有箭头函数的需要编译的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAll</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终会变成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAll</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而，它依然无法随处可用因为不是所有的 JavaScript 环境都支持 <code>Array.from</code>。</p>
<pre><code>Uncaught TypeError: Array.from is not a function
</code></pre><p>为了解决这个问题，我们使用一种叫做 <a href="https://remysharp.com/2010/10/08/what-is-a-polyfill" target="_blank" rel="external">Polyfill（代码填充，也可译作兼容性补丁）</a> 的技术。 简单地说，polyfill 即是在当前运行环境中用来复制（意指模拟性的复制，而不是拷贝）尚不存在的原生 api 的代码。 能让你提前使用还不可用的 APIs，<code>Array.from</code> 就是一个例子。</p>
<p>Babel 用了优秀的 <a href="https://github.com/zloirock/core-js" target="_blank" rel="external">core-js</a> 用作 polyfill，并且还有定制化的 <a href="https://github.com/facebook/regenerator" target="_blank" rel="external">regenerator</a> 来让 generators（生成器）和 async functions（异步函数）正常工作。</p>
<p>要使用 Babel polyfill，首先用 npm 安装它：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save babel-polyfill</div></pre></td></tr></table></figure>
<p>然后只需要在文件顶部导入 polyfill 就可以了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"babel-polyfill"</span>;</div></pre></td></tr></table></figure>
<h2 id="babel-runtime"><a href="#babel-runtime" class="headerlink" title="babel-runtime"></a><a id="toc-babel-runtime"></a><code>babel-runtime</code></h2><p>为了实现 ECMAScript 规范的细节，Babel 会使用“助手”方法来保持生成代码的整洁。</p>
<p>由于这些助手方法可能会特别长并且会被添加到每一个文件的顶部，因此你可以把它们统一移动到一个单一的“运行时（runtime）”中去。</p>
<p>通过安装 <code>babel-plugin-transform-runtime</code> 和 <code>babel-runtime</code> 来开始。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev babel-plugin-transform-runtime</div><div class="line">$ npm install --save babel-runtime</div></pre></td></tr></table></figure>
<p>然后更新 <code>.babelrc</code>：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  &#123;</div><div class="line">    "plugins": [</div><div class="line"><span class="addition">+     "transform-runtime",</span></div><div class="line">      "transform-es2015-classes"</div><div class="line">    ]</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>现在，Babel 会把这样的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  method() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> _classCallCheck <span class="keyword">from</span> <span class="string">"babel-runtime/helpers/classCallCheck"</span>;</div><div class="line"><span class="keyword">import</span> _createClass <span class="keyword">from</span> <span class="string">"babel-runtime/helpers/createClass"</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> Foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    _classCallCheck(<span class="keyword">this</span>, Foo);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  _createClass(Foo, [&#123;</div><div class="line">    <span class="attr">key</span>: <span class="string">"method"</span>,</div><div class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">  &#125;]);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> Foo;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>这样就不需要把 <code>_classCallCheck</code> 和 <code>_createClass</code> 这两个助手方法放进每一个需要的文件里去了。</p>
<hr>
<h1 id="配置-Babel（进阶）"><a href="#配置-Babel（进阶）" class="headerlink" title="配置 Babel（进阶）"></a><a id="toc-configuring-babel-advanced"></a>配置 Babel（进阶）</h1><p>大多数人使用 Babel 的内建预设就足够了，不过 Babel 提供了更多更细粒度的能力。</p>
<h2 id="手动指定插件"><a href="#手动指定插件" class="headerlink" title="手动指定插件"></a><a id="toc-manually-specifying-plugins"></a>手动指定插件</h2><p>Babel 预设就是一些预先配置好的插件的集合，如果你想要做一些不一样的事情你会手动去设定插件，这和使用预设几乎完全相同。</p>
<p>首先安装插件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev babel-plugin-transform-es2015-classes</div></pre></td></tr></table></figure>
<p>然后往 <code>.babelrc</code> 文件添加 <code>plugins</code> 字段。.</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  &#123;</div><div class="line"><span class="addition">+   "plugins": [</span></div><div class="line"><span class="addition">+     "transform-es2015-classes"</span></div><div class="line"><span class="addition">+   ]</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这能让你对正在使用的转换器进行更细致的控制。</p>
<p>完整的官方插件列表请见 <a href="http://babeljs.io/docs/plugins/" target="_blank" rel="external">Babel 插件页面</a>。.</p>
<p>同时也别忘了看看<a href="https://www.npmjs.com/search?q=babel-plugin" target="_blank" rel="external">由社区构建的其他插件</a>。 如果你想学习如何编写自己的插件可以阅读 <a href="plugin-handbook.md">Babel 插件手册</a>。.</p>
<h2 id="插件选项"><a href="#插件选项" class="headerlink" title="插件选项"></a><a id="toc-plugin-options"></a>插件选项</h2><p>很多插件也有选项用于配置他们自身的行为。 例如，很多转换器都有“宽松”模式，通过放弃一些标准中的行为来生成更简化且性能更好的代码。</p>
<p>要为插件添加选项，只需要做出以下更改：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  &#123;</div><div class="line">    "plugins": [</div><div class="line"><span class="deletion">-     "transform-es2015-classes"</span></div><div class="line"><span class="addition">+     ["transform-es2015-classes", &#123; "loose": true &#125;]</span></div><div class="line">    ]</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>接下来几周内我会更新插件文档来详细介绍每一个选项。<a href="https://twitter.com/thejameskyle" target="_blank" rel="external">关注我以获知更新</a>。.</p>
</blockquote>
<h2 id="基于环境自定义-Babel"><a href="#基于环境自定义-Babel" class="headerlink" title="基于环境自定义 Babel"></a><a id="toc-customizing-babel-based-on-environment"></a>基于环境自定义 Babel</h2><p>Babel 插件解决许多不同的问题。 其中大多数是开发工具，可以帮助你调试代码或是与工具集成。 也有大量的插件用于在生产环境中优化你的代码。</p>
<p>因此，想要基于环境来配置 Babel 是很常见的。你可以轻松的使用 <code>.babelrc</code> 文件来达成目的。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">  &#123;</div><div class="line">    "presets": ["es2015"],</div><div class="line">    "plugins": [],</div><div class="line"><span class="addition">+   "env": &#123;</span></div><div class="line"><span class="addition">+     "development": &#123;</span></div><div class="line"><span class="addition">+       "plugins": [...]</span></div><div class="line"><span class="addition">+     &#125;,</span></div><div class="line"><span class="addition">+     "production": &#123;</span></div><div class="line"><span class="addition">+       "plugins": [...]</span></div><div class="line"><span class="addition">+     &#125;</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>Babel 将根据当前环境来开启 <code>env</code> 下的配置。</p>
<p>当前环境可以使用 <code>process.env.BABEL_ENV</code> 来获得。 如果 <code>BABEL_ENV</code> 不可用，将会替换成 <code>NODE_ENV</code>，并且如果后者也没有设置，那么缺省值是<code>&quot;development&quot;</code>。.</p>
<p><strong>Unix</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ BABEL_ENV=production [COMMAND]</div><div class="line">$ NODE_ENV=production [COMMAND]</div></pre></td></tr></table></figure>
<p><strong>Windows</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ SET BABEL_ENV=production</div><div class="line">$ [COMMAND]</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong><code>[COMMAND]</code> 指的是任意一个用来运行 Babel 的命令（如：<code>babel</code>，<code>babel-node</code>，或是 <code>node</code>，如果你使用了 register 钩子的话）。</p>
<p><strong>提示：</strong>如果你想要让命令能够跨 unix 和 windows 平台运行的话，可以使用 <a href="https://www.npmjs.com/package/cross-env" target="_blank" rel="external"><code>cross-env</code></a>。.</p>
</blockquote>
<h2 id="制作你自己的预设（preset）"><a href="#制作你自己的预设（preset）" class="headerlink" title="制作你自己的预设（preset）"></a><a id="toc-making-your-own-preset"></a>制作你自己的预设（preset）</h2><p>手动指定插件？插件选项？环境特定设置？所有这些配置都会在你的项目里产生大量的重复工作。</p>
<p>为此，我们鼓励社区创建自己的预设。 这可能是一个针对特定 <a href="https://github.com/leebenson/babel-preset-node5" target="_blank" rel="external">node 版本</a>的预设，或是适用于你<a href="https://github.com/cloudflare/babel-preset-cf" target="_blank" rel="external">整个</a><a href="https://github.com/airbnb/babel-preset-airbnb" target="_blank" rel="external">公司</a>的预设。.</p>
<p>创建预设非常容易。比方说你这样一个 <code>.babelrc</code> 文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"presets"</span>: [</div><div class="line">    <span class="string">"es2015"</span>,</div><div class="line">    <span class="string">"react"</span></div><div class="line">  ],</div><div class="line">  <span class="string">"plugins"</span>: [</div><div class="line">    <span class="string">"transform-flow-strip-types"</span></div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你要做的就是依循命名约定 <code>babel-preset-*</code> 来创建一个新项目（请务必对这个命名约定保持责任心，也就是说不要滥用这个命名空间），然后创建两个文件。</p>
<p>首先，创建一个 <code>package.json</code>，包括针对预设所必要的 <code>dependencies</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"babel-preset-my-awesome-preset"</span>,</div><div class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</div><div class="line">  <span class="string">"author"</span>: <span class="string">"James Kyle &lt;me@thejameskyle.com&gt;"</span>,</div><div class="line">  <span class="string">"dependencies"</span>: &#123;</div><div class="line">    <span class="string">"babel-preset-es2015"</span>: <span class="string">"^6.3.13"</span>,</div><div class="line">    <span class="string">"babel-preset-react"</span>: <span class="string">"^6.3.13"</span>,</div><div class="line">    <span class="string">"babel-plugin-transform-flow-strip-types"</span>: <span class="string">"^6.3.15"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后创建 <code>index.js</code> 文件用于导出 <code>.babelrc</code> 的内容，使用对应的 <code>require</code> 调用来替换 plugins／presets 字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">presets</span>: [</div><div class="line">    <span class="built_in">require</span>(<span class="string">"babel-preset-es2015"</span>),</div><div class="line">    <span class="built_in">require</span>(<span class="string">"babel-preset-react"</span>)</div><div class="line">  ],</div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">    <span class="built_in">require</span>(<span class="string">"babel-plugin-transform-flow-strip-types"</span>)</div><div class="line">  ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后只需要发布到 npm 于是你就可以像其它预设一样来使用你的预设了。</p>
<hr>
<h1 id="Babel-和其他工具"><a href="#Babel-和其他工具" class="headerlink" title="Babel 和其他工具"></a><a id="toc-babel-and-other-tools"></a>Babel 和其他工具</h1><p>一旦你掌握的窍门，安装 Babel 还是十分简明的，不过和其他工具搭配在一起就会变得困难多了。 不过我们一直在与其他项目密切合作以确保这种体验尽可能简单。</p>
<h2 id="静态分析工具"><a href="#静态分析工具" class="headerlink" title="静态分析工具"></a><a id="toc-static-analysis-tools"></a>静态分析工具</h2><p>新标准为语言带来了许多新的语法，静态分析工具正在将此利用起来。</p>
<h3 id="语法检查（Linting）"><a href="#语法检查（Linting）" class="headerlink" title="语法检查（Linting）"></a><a id="toc-linting"></a>语法检查（Linting）</h3><p><a href="http://eslint.org" target="_blank" rel="external">ESLint</a> 是最流行的语法检查工具之一，因此我们维护了一个官方的 <a href="https://github.com/babel/babel-eslint" target="_blank" rel="external"><code>babel-eslint</code></a> 整合软件包。</p>
<p>首先安装 <code>eslint</code> 和 <code>babel-eslint</code>。.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev eslint babel-eslint</div></pre></td></tr></table></figure>
<p>然后创建或使用项目现有的 <code>.eslintrc</code> 文件并设置 <code>parser</code> 为 <code>babel-eslint</code>。.</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  &#123;</div><div class="line"><span class="addition">+   "parser": "babel-eslint",</span></div><div class="line">    "rules": &#123;</div><div class="line">      ...</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>现在添加一个 <code>lint</code> 任务到 npm 的 <code>package.json</code> 脚本中：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  &#123;</div><div class="line">    "name": "my-module",</div><div class="line">    "scripts": &#123;</div><div class="line"><span class="addition">+     "lint": "eslint my-files.js"</span></div><div class="line">    &#125;,</div><div class="line">    "devDependencies": &#123;</div><div class="line">      "babel-eslint": "...",</div><div class="line">      "eslint": "..."</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>接着只需要运行这个任务就一切就绪了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm run lint</div></pre></td></tr></table></figure>
<p>详细信息请咨询 <a href="https://github.com/babel/babel-eslint" target="_blank" rel="external"><code>babel-eslint</code></a> 或者 <a href="http://eslint.org" target="_blank" rel="external"><code>eslint</code></a> 的文档。</p>
<h3 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a><a id="toc-code-style"></a>代码风格</h3><blockquote>
<p>JSCS已经和ESLint合并，所以请查看ESLint的代码风格。</p>
</blockquote>
<p>JSCS 是一个极受欢迎的工具，在语法检查的基础上更进一步检查代码自身的风格。 Babel 和 JSCS 项目的核心维护者之一（<a href="https://github.com/hzoo" target="_blank" rel="external">@hzoo</a>）维护着 JSCS 的官方集成。</p>
<p>更妙的是，JSCS 自己通过 <code>--esnext</code> 选项实现了这种集成，于是和 Babel 的集成就简化成了直接在命令行运行：</p>
<pre><code>$ jscs . --esnext
</code></pre><p>或者在 <code>.jscsrc</code> 文件里添加 <code>esnext</code> 选项。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  &#123;</div><div class="line">    "preset": "airbnb",</div><div class="line"><span class="addition">+   "esnext": true</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>详细信息请咨询 <a href="https://github.com/jscs-dev/babel-jscs" target="_blank" rel="external"><code>babel-jscs</code></a> 或是 <a href="http://jscs.info" target="_blank" rel="external"><code>jscs</code></a> 的文档。</p>
<!--
### Code Coverage

> [WIP]
-->
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a><a id="toc-documentation"></a>文档</h3><p>使用 Babel，ES2015，还有 Flow 你可以对你的代码进行大量的推断。使用 <a href="http://documentation.js.org" target="_blank" rel="external">documentation.js</a> 可以非常简便地生成详细的 API 文档。</p>
<p>Documentation.js 使用 Babel 来支持所有最新的语法，包括用于在你的代码中声明类型所用的 Flow 注解在内，</p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a><a id="toc-frameworks"></a>框架</h2><p>所有主流的 JavaScript 框架都正在努力调整他们的 APIs 向这门语言的未来看齐。有鉴于此，配套工具方面已经做出了大量的工作。</p>
<p>除了使用 Babel 以外，框架更有条件去扩展 Babel 来帮助他们提升用户体验。</p>
<h3 id="React"><a href="#React" class="headerlink" title="React"></a><a id="toc-react"></a>React</h3><p>React 已经大幅改变了他们的 API 以适应 ES2015 的类语法（<a href="https://babeljs.io/blog/2015/06/07/react-on-es6-plus" target="_blank" rel="external">此处了解更新的 API</a>）。 特别是 React 现在依赖 Babel 编译它的 JSX 语法且弃用了它原有的自定义工具。 你可以按照<a href="#babel-preset-react">上述说明</a>安装 <code>babel-preset-react</code> 包来开始。.</p>
<p>React 社区采用 Babel 并围绕它来运行，现在社区已经创建了<a href="https://www.npmjs.com/search?q=babel-plugin+react" target="_blank" rel="external">大量的转换器（transforms）</a>。.</p>
<p>最令人瞩目的是 <a href="https://github.com/gaearon/babel-plugin-react-transform" target="_blank" rel="external"><code>babel-plugin-react-transform</code></a> 插件，它集成了大量 <a href="https://github.com/gaearon/babel-plugin-react-transform#transforms" target="_blank" rel="external">React 专用转换器</a>可以启用诸如 <em>热模块重载</em>等其他调试工具。</p>
<!--
### Ember

> [WIP]
-->
<h2 id="文本编辑器和-IDEs（集成开发环境）"><a href="#文本编辑器和-IDEs（集成开发环境）" class="headerlink" title="文本编辑器和 IDEs（集成开发环境）"></a><a id="toc-text-editors-and-ides"></a>文本编辑器和 IDEs（集成开发环境）</h2><p>通过 Babel 引入 ES2015，JSX，和流式语法固然是大有裨益，可如果你的文本编辑不支持那可就糟糕透了。 因此，别忘了为你的文本编辑器或是 IDE 安装 Babel 插件。</p>
<ul>
<li><a href="https://github.com/babel/babel-sublime" target="_blank" rel="external">Sublime Text</a></li>
<li><a href="https://atom.io/packages/language-babel" target="_blank" rel="external">Atom</a></li>
<li><a href="https://github.com/jbgutierrez/vim-babel" target="_blank" rel="external">Vim</a></li>
<li><a href="https://babeljs.io/docs/setup/#webstorm" target="_blank" rel="external">WebStorm</a></li>
</ul>
<!--
# Debugging Babel

> [WIP]
-->
<hr>
<h1 id="Babel-支持"><a href="#Babel-支持" class="headerlink" title="Babel 支持"></a><a id="toc-babel-support"></a>Babel 支持</h1><p>Babel 的社区非常庞大并且增长速度很快，伴随着我们成长的同时我们希望保证人们总能获取他们需要的所有资源。 所以我们提供了数种途径来提供支持。</p>
<p>谨记在所有的这些沟通渠道里我们都共同遵守一套<a href="https://github.com/babel/babel/blob/master/CODE_OF_CONDUCT.md" target="_blank" rel="external">行为准则</a>。 破坏准则的行为会被处理。 所以请阅读它并在与他人互动时注意自己的行为。</p>
<p>同时我们也在寻求发展一个自我支持式的社区，为那些始终热诚奉献的人们。 如果别人问的问题你恰好知道答案，请不吝花费几分钟帮帮他们。 在此过程中也请尽力保持友善与相互理解。</p>
<h2 id="Babel-论坛"><a href="#Babel-论坛" class="headerlink" title="Babel 论坛"></a><a id="toc-babel-forum"></a>Babel 论坛</h2><p><a href="http://www.discourse.org" target="_blank" rel="external">Discourse</a> 免费为我们提供了一个托管版本的论坛（我们爱死他们了！）。 如果你是个论坛控请不要错过 <a href="https://discuss.babeljs.io" target="_blank" rel="external">discuss.babeljs.io</a>。.</p>
<h2 id="Babel-聊天"><a href="#Babel-聊天" class="headerlink" title="Babel 聊天"></a><a id="toc-babel-chat"></a>Babel 聊天</h2><p>无人不爱 <a href="https://slack.com" target="_blank" rel="external">Slack</a>。如果你正在寻求来自社区的即时支持，那就来 <a href="https://slack.babeljs.io" target="_blank" rel="external">slack.babeljs.io</a> 和我们聊天吧。.</p>
<!--
## Babel Stack Overflow

> [WIP]
-->
<h2 id="Babel-问题"><a href="#Babel-问题" class="headerlink" title="Babel 问题"></a><a id="toc-babel-issues"></a>Babel 问题</h2><p>Babel使用<a href="http://github.com" target="_blank" rel="external">Github</a>提供的问题跟踪器。.</p>
<p>您可以在<a href="https://github.com/babel/babel/issues" target="_blank" rel="external">Github</a>上看到所有的开放和封闭的问题.</p>
<p>如果你想要打开一个新的问题：</p>
<ul>
<li><a href="https://github.com/babel/babel/issues" target="_blank" rel="external">先搜搜看有没有现存的类似问题</a></li>
<li><p>创建一个新的错误报告&lt;/&gt; 或请求新功能&lt;/&gt;</p></li> </ul> <p></p>
<h3 id="创建漂亮的-Babel-错误报告"><a href="#创建漂亮的-Babel-错误报告" class="headerlink" title="创建漂亮的 Babel 错误报告"></a><a id="toc-creating-an-awesome-babel-bug-report"></a>创建漂亮的 Babel 错误报告</h3><p>Babel 的问题有时候很难远程调试，所以我们希望能获取尽可能详细的信息来帮助我们解决问题。 花点时间去撰写一份好的错误报告会让你的问题更快得到解决。</p>
<p>首先，尝试隔离问题。 并非设置过程的每一步都是导致问题的原因。 如果你的问题是一段输入代码，试着尽可能把与问题不相关的代码都删除掉。</p>
<blockquote>
<p>[WIP]</p>
</blockquote>
<hr>
<blockquote>
<p><strong><em>在 Twitter 上关注 <a href="https://twitter.com/thejameskyle" target="_blank" rel="external">@thejameskyle</a>，第一时间获取更新。</em></strong></p>
</blockquote>


]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Babel-用户手册&quot;&gt;&lt;a href=&quot;#Babel-用户手册&quot; class=&quot;headerlink&quot; title=&quot;Babel 用户手册&quot;&gt;&lt;/a&gt;Babel 用户手册&lt;/h1&gt;&lt;p&gt;这本手册涵盖了关于 &lt;a href=&quot;https://babeljs.io&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://lzm420241.github.io/2018/05/21/Babel%20%E6%8F%92%E4%BB%B6%E6%89%8B%E5%86%8C/"/>
    <id>https://lzm420241.github.io/2018/05/21/Babel 插件手册/</id>
    <published>2018-05-21T06:35:01.000Z</published>
    <updated>2018-05-21T06:35:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Babel-插件手册"><a href="#Babel-插件手册" class="headerlink" title="Babel 插件手册"></a>Babel 插件手册</h1><p>这篇文档涵盖了如何创建 <a href="https://babeljs.io" target="_blank" rel="external">Babel</a> <a href="https://babeljs.io/docs/advanced/plugins/" target="_blank" rel="external">插件</a>等方面的内容。.</p>
<p><a href="http://creativecommons.org/licenses/by/4.0/" target="_blank" rel="external"><img src="https://licensebuttons.net/l/by/4.0/80x15.png" alt="cc-by-4.0"></a></p>
<p>这本手册提供了多种语言的版本，查看 <a href="/README.md">自述文件</a> 里的完整列表。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#toc-introduction">介绍</a></li>
<li><a href="#toc-basics">基础</a> <ul>
<li><a href="#toc-asts">抽象语法树（ASTs）</a></li>
<li><a href="#toc-stages-of-babel">Babel 的处理步骤</a></li>
<li><a href="#toc-parse">解析</a> <ul>
<li><a href="#toc-lexical-analysis">词法分析</a></li>
<li><a href="#toc-syntactic-analysis">语法分析</a></li>
</ul>
</li>
<li><a href="#toc-transform">转换</a></li>
<li><a href="#toc-generate">生成</a></li>
<li><a href="#toc-traversal">遍历</a></li>
<li><a href="#toc-visitors">Visitors（访问者）</a></li>
<li><a href="#toc-paths">Paths（路径）</a> <ul>
<li><a href="#toc-paths-in-visitors">Paths in Visitors（存在于访问者中的路径）</a></li>
</ul>
</li>
<li><a href="#toc-state">State（状态）</a></li>
<li><a href="#toc-scopes">Scopes（作用域）</a> <ul>
<li><a href="#toc-bindings">Bindings（绑定）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#toc-api">API</a> <ul>
<li><a href="#toc-babylon">babylon</a></li>
<li><a href="#toc-babel-traverse">babel-traverse</a></li>
<li><a href="#toc-babel-types">babel-types</a></li>
<li><a href="#toc-definitions">Definitions（定义）</a></li>
<li><a href="#toc-builders">Builders（构建器）</a></li>
<li><a href="#toc-validators">Validators（验证器）</a></li>
<li><a href="#toc-converters">Converters（变换器）</a></li>
<li><a href="#toc-babel-generator">babel-generator</a></li>
<li><a href="#toc-babel-template">babel-template</a></li>
</ul>
</li>
<li><a href="#toc-writing-your-first-babel-plugin">编写你的第一个 Babel 插件</a></li>
<li><a href="#toc-transformation-operations">转换操作</a> <ul>
<li><a href="#toc-visiting">访问</a></li>
<li><a href="#toc-get-the-path-of-a-sub-node">获取子节点的Path</a></li>
<li><a href="#toc-check-if-a-node-is-a-certain-type">检查节点（Node）类型</a></li>
<li><a href="#toc-check-if-a-path-is-a-certain-type">检查路径（Path）类型</a></li>
<li><a href="#toc-check-if-an-identifier-is-referenced">检查标识符（Identifier）是否被引用</a></li>
<li><a href="#toc-find-a-specific-parent-path">找到特定的父路径</a></li>
<li><a href="#toc-get-sibling-paths">获取同级路径</a></li>
<li><a href="#toc-stopping-traversal">停止遍历</a></li>
<li><a href="#toc-manipulation">处理</a></li>
<li><a href="#toc-replacing-a-node">替换一个节点</a></li>
<li><a href="#toc-replacing-a-node-with-multiple-nodes">用多节点替换单节点</a></li>
<li><a href="#toc-replacing-a-node-with-a-source-string">用字符串源码替换节点</a></li>
<li><a href="#toc-inserting-a-sibling-node">插入兄弟节点</a></li>
<li><a href="#toc-inserting-into-a-container">插入到容器（container）中</a></li>
<li><a href="#toc-removing-a-node">删除节点</a></li>
<li><a href="#toc-replacing-a-parent">替换父节点</a></li>
<li><a href="#toc-removing-a-parent">删除父节点</a></li>
<li><a href="#toc-scope">Scope（作用域）</a></li>
<li><a href="#toc-checking-if-a-local-variable-is-bound">检查本地变量是否被绑定</a></li>
<li><a href="#toc-generating-a-uid">生成UID</a></li>
<li><a href="#toc-pushing-a-variable-declaration-to-a-parent-scope">提升变量声明至父级作用域</a></li>
<li><a href="#toc-rename-a-binding-and-its-references">重命名绑定及其引用</a></li>
</ul>
</li>
<li><a href="#toc-plugin-options">插件选项</a> <ul>
<li><a href="#toc-pre-and-post-in-plugins">插件的准备和收尾工作</a></li>
<li><a href="#toc-enabling-syntax-in-plugins">在插件中启用其他语法</a></li>
</ul>
</li>
<li><a href="#toc-building-nodes">构建节点</a></li>
<li><a href="#toc-best-practices">最佳实践</a> <ul>
<li><a href="#toc-avoid-traversing-the-ast-as-much-as-possible">尽量避免遍历抽象语法树（AST）</a></li>
<li><a href="#toc-merge-visitors-whenever-possible">及时合并访问者对象</a></li>
<li><a href="#toc-do-not-traverse-when-manual-lookup-will-do">可以手动查找就不要遍历</a></li>
<li><a href="#toc-optimizing-nested-visitors">优化嵌套的访问者对象</a></li>
<li><a href="#toc-being-aware-of-nested-structures">留意嵌套结构</a></li>
<li><a href="#toc-unit-testing">单元测试</a></li>
</ul>
</li>
</ul>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><a id="toc-introduction"></a>介绍</h1><p>Babel 是一个通用的多功能的 JavaScript 编译器。此外它还拥有众多模块可用于不同形式的静态分析。</p>
<blockquote>
<p>静态分析是在不需要执行代码的前提下对代码进行分析的处理过程 （执行代码的同时进行代码分析即是动态分析）。 静态分析的目的是多种多样的， 它可用于语法检查，编译，代码高亮，代码转换，优化，压缩等等场景。</p>
</blockquote>
<p>你可以使用 Babel 创建多种类型的工具来帮助你更有效率并且写出更好的程序。</p>
<blockquote>
<p><strong><em>在 Twitter 上关注 <a href="https://twitter.com/thejameskyle" target="_blank" rel="external">@thejameskyle</a>，第一时间获取更新。</em></strong></p>
</blockquote>
<hr>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a><a id="toc-basics"></a>基础</h1><p>Babel 是 JavaScript 编译器，更确切地说是源码到源码的编译器，通常也叫做“转换编译器（transpiler）”。 意思是说你为 Babel 提供一些 JavaScript 代码，Babel 更改这些代码，然后返回给你新生成的代码。</p>
<h2 id="抽象语法树（ASTs）"><a href="#抽象语法树（ASTs）" class="headerlink" title="抽象语法树（ASTs）"></a><a id="toc-asts"></a>抽象语法树（ASTs）</h2><p>这个处理过程中的每一步都涉及到创建或是操作<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="external">抽象语法树</a>，亦称 AST。</p>
<blockquote>
<p>Babel 使用一个基于 <a href="https://github.com/estree/estree" target="_blank" rel="external">ESTree</a> 并修改过的 AST，它的内核说明文档可以在<a href="https://github. com/babel/babel/blob/master/doc/ast/spec. md" target="_blank" rel="external">这里</a>找到。.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://astexplorer.net/" target="_blank" rel="external">AST Explorer</a> 可以让你对 AST 节点有一个更好的感性认识。 <a href="http://astexplorer.net/#/Z1exs6BWMq" target="_blank" rel="external">这里</a>是上述代码的一个示例链接。</p>
</blockquote>
<p>这个程序可以被表示成如下的一棵树：</p>
<figure class="highlight md"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">- </span>FunctionDeclaration:</div><div class="line">  - id:</div><div class="line"><span class="code">    - Identifier:</span></div><div class="line"><span class="code">      - name: square</span></div><div class="line">  - params [1]</div><div class="line"><span class="code">    - Identifier</span></div><div class="line"><span class="code">      - name: n</span></div><div class="line">  - body:</div><div class="line"><span class="code">    - BlockStatement</span></div><div class="line"><span class="code">      - body [1]</span></div><div class="line"><span class="code">        - ReturnStatement</span></div><div class="line"><span class="code">          - argument</span></div><div class="line"><span class="code">            - BinaryExpression</span></div><div class="line"><span class="code">              - operator: *</span></div><div class="line"><span class="code">              - left</span></div><div class="line"><span class="code">                - Identifier</span></div><div class="line"><span class="code">                  - name: n</span></div><div class="line"><span class="code">              - right</span></div><div class="line"><span class="code">                - Identifier</span></div><div class="line"><span class="code">                  - name: n</span></div></pre></td></tr></table></figure>
<p>或是如下所示的 JavaScript Object（对象）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">"FunctionDeclaration"</span>,</div><div class="line">  <span class="attr">id</span>: &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">"square"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">params</span>: [&#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">"n"</span></div><div class="line">  &#125;],</div><div class="line">  <span class="attr">body</span>: &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">"BlockStatement"</span>,</div><div class="line">    <span class="attr">body</span>: [&#123;</div><div class="line">      <span class="attr">type</span>: <span class="string">"ReturnStatement"</span>,</div><div class="line">      <span class="attr">argument</span>: &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"BinaryExpression"</span>,</div><div class="line">        <span class="attr">operator</span>: <span class="string">"*"</span>,</div><div class="line">        <span class="attr">left</span>: &#123;</div><div class="line">          <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">          <span class="attr">name</span>: <span class="string">"n"</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">right</span>: &#123;</div><div class="line">          <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">          <span class="attr">name</span>: <span class="string">"n"</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你会留意到 AST 的每一层都拥有相同的结构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">"FunctionDeclaration"</span>,</div><div class="line">  <span class="attr">id</span>: &#123;...&#125;,</div><div class="line">  <span class="attr">params</span>: [...],</div><div class="line">  <span class="attr">body</span>: &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">  <span class="attr">name</span>: ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">"BinaryExpression"</span>,</div><div class="line">  <span class="attr">operator</span>: ...,</div><div class="line">  <span class="attr">left</span>: &#123;...&#125;,</div><div class="line">  <span class="attr">right</span>: &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：出于简化的目的移除了某些属性</p>
</blockquote>
<p>这样的每一层结构也被叫做 <strong>节点（Node）</strong>。 一个 AST 可以由单一的节点或是成百上千个节点构成。 它们组合在一起可以描述用于静态分析的程序语法。</p>
<p>每一个节点都有如下所示的接口（Interface）：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Node &#123;</div><div class="line">  <span class="keyword">type</span>: <span class="built_in">string</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>字符串形式的 <code>type</code> 字段表示节点的类型（如： <code>&quot;FunctionDeclaration&quot;</code>，<code>&quot;Identifier&quot;</code>，或 <code>&quot;BinaryExpression&quot;</code>）。 每一种类型的节点定义了一些附加属性用来进一步描述该节点类型。</p>
<p>Babel 还为每个节点额外生成了一些属性，用于描述该节点在原始代码中的位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">type</span>: ...,</div><div class="line">  <span class="attr">start</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">end</span>: <span class="number">38</span>,</div><div class="line">  <span class="attr">loc</span>: &#123;</div><div class="line">    <span class="attr">start</span>: &#123;</div><div class="line">      <span class="attr">line</span>: <span class="number">1</span>,</div><div class="line">      <span class="attr">column</span>: <span class="number">0</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">end</span>: &#123;</div><div class="line">      <span class="attr">line</span>: <span class="number">3</span>,</div><div class="line">      <span class="attr">column</span>: <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每一个节点都会有 <code>start</code>，<code>end</code>，<code>loc</code> 这几个属性。</p>
<h2 id="Babel-的处理步骤"><a href="#Babel-的处理步骤" class="headerlink" title="Babel 的处理步骤"></a><a id="toc-stages-of-babel"></a>Babel 的处理步骤</h2><p>Babel 的三个主要处理步骤分别是： <strong>解析（parse）</strong>，<strong>转换（transform）</strong>，<strong>生成（generate）</strong>。.</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a><a id="toc-parse"></a>解析</h3><p><strong>解析</strong>步骤接收代码并输出 AST。 这个步骤分为两个阶段：<a href="https://en.wikipedia.org/wiki/Lexical_analysis" target="_blank" rel="external"><strong>词法分析（Lexical Analysis） </strong></a>和 <a href="https://en.wikipedia.org/wiki/Parsing" target="_blank" rel="external"><strong>语法分析（Syntactic Analysis）</strong></a>。.</p>
<h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a><a id="toc-lexical-analysis"></a>词法分析</h4><p>词法分析阶段把字符串形式的代码转换为 <strong>令牌（tokens）</strong> 流。.</p>
<p>你可以把令牌看作是一个扁平的语法片段数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">n * n;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  &#123; <span class="attr">type</span>: &#123; ... &#125;, <span class="attr">value</span>: <span class="string">"n"</span>, <span class="attr">start</span>: <span class="number">0</span>, <span class="attr">end</span>: <span class="number">1</span>, <span class="attr">loc</span>: &#123; ... &#125; &#125;,</div><div class="line">  &#123; <span class="attr">type</span>: &#123; ... &#125;, <span class="attr">value</span>: <span class="string">"*"</span>, <span class="attr">start</span>: <span class="number">2</span>, <span class="attr">end</span>: <span class="number">3</span>, <span class="attr">loc</span>: &#123; ... &#125; &#125;,</div><div class="line">  &#123; <span class="attr">type</span>: &#123; ... &#125;, <span class="attr">value</span>: <span class="string">"n"</span>, <span class="attr">start</span>: <span class="number">4</span>, <span class="attr">end</span>: <span class="number">5</span>, <span class="attr">loc</span>: &#123; ... &#125; &#125;,</div><div class="line">  ...</div><div class="line">]</div></pre></td></tr></table></figure>
<p>每一个 <code>type</code> 有一组属性来描述该令牌：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">type</span>: &#123;</div><div class="line">    <span class="attr">label</span>: <span class="string">'name'</span>,</div><div class="line">    <span class="attr">keyword</span>: <span class="literal">undefined</span>,</div><div class="line">    <span class="attr">beforeExpr</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">startsExpr</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">rightAssociative</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">isLoop</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">isAssign</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">prefix</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">postfix</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">binop</span>: <span class="literal">null</span>,</div><div class="line">    <span class="attr">updateContext</span>: <span class="literal">null</span></div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和 AST 节点一样它们也有 <code>start</code>，<code>end</code>，<code>loc</code> 属性。.</p>
<h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a><a id="toc-syntactic-analysis"></a>语法分析</h4><p>语法分析阶段会把一个令牌流转换成 AST 的形式。 这个阶段会使用令牌中的信息把它们转换成一个 AST 的表述结构，这样更易于后续的操作。</p>
<h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a><a id="toc-transform"></a>转换</h3><p><a href="https://en.wikipedia.org/wiki/Program_transformation" target="_blank" rel="external">转换</a>步骤接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作。 这是 Babel 或是其他编译器中最复杂的过程 同时也是插件将要介入工作的部分，这将是本手册的主要内容， 因此让我们慢慢来。</p>
<h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a><a id="toc-generate"></a>生成</h3><p><a href="https://en.wikipedia.org/wiki/Code_generation_(compiler" target="_blank" rel="external">代码生成</a>)步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建<a href="http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/" target="_blank" rel="external">源码映射（source maps）</a>。.</p>
<p>代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a><a id="toc-traversal"></a>遍历</h2><p>想要转换 AST 你需要进行递归的<a href="https://en.wikipedia.org/wiki/Tree_traversal" target="_blank" rel="external">树形遍历</a>。</p>
<p>比方说我们有一个 <code>FunctionDeclaration</code> 类型。它有几个属性：<code>id</code>，<code>params</code>，和 <code>body</code>，每一个都有一些内嵌节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">"FunctionDeclaration"</span>,</div><div class="line">  <span class="attr">id</span>: &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">"square"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">params</span>: [&#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">"n"</span></div><div class="line">  &#125;],</div><div class="line">  <span class="attr">body</span>: &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">"BlockStatement"</span>,</div><div class="line">    <span class="attr">body</span>: [&#123;</div><div class="line">      <span class="attr">type</span>: <span class="string">"ReturnStatement"</span>,</div><div class="line">      <span class="attr">argument</span>: &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"BinaryExpression"</span>,</div><div class="line">        <span class="attr">operator</span>: <span class="string">"*"</span>,</div><div class="line">        <span class="attr">left</span>: &#123;</div><div class="line">          <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">          <span class="attr">name</span>: <span class="string">"n"</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">right</span>: &#123;</div><div class="line">          <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">          <span class="attr">name</span>: <span class="string">"n"</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>于是我们从 <code>FunctionDeclaration</code> 开始并且我们知道它的内部属性（即：<code>id</code>，<code>params</code>，<code>body</code>），所以我们依次访问每一个属性及它们的子节点。</p>
<p>接着我们来到 <code>id</code>，它是一个 <code>Identifier</code>。<code>Identifier</code> 没有任何子节点属性，所以我们继续。</p>
<p>之后是 <code>params</code>，由于它是一个数组节点所以我们访问其中的每一个，它们都是 <code>Identifier</code> 类型的单一节点，然后我们继续。</p>
<p>此时我们来到了 <code>body</code>，这是一个 <code>BlockStatement</code> 并且也有一个 <code>body</code>节点，而且也是一个数组节点，我们继续访问其中的每一个。</p>
<p>这里唯一的一个属性是 <code>ReturnStatement</code> 节点，它有一个 <code>argument</code>，我们访问 <code>argument</code> 就找到了 <code>BinaryExpression</code>。.</p>
<p><code>BinaryExpression</code> 有一个 <code>operator</code>，一个 <code>left</code>，和一个 <code>right</code>。 Operator 不是一个节点，它只是一个值因此我们不用继续向内遍历，我们只需要访问 <code>left</code> 和 <code>right</code>。.</p>
<p>Babel 的转换步骤全都是这样的遍历过程。</p>
<h3 id="Visitors（访问者）"><a href="#Visitors（访问者）" class="headerlink" title="Visitors（访问者）"></a><a id="toc-visitors"></a>Visitors（访问者）</h3><p>当我们谈及“进入”一个节点，实际上是说我们在<strong>访问</strong>它们， 之所以使用这样的术语是因为有一个<a href="https://en.wikipedia.org/wiki/Visitor_pattern" target="_blank" rel="external"><strong>访问者模式（visitor）</strong></a>的概念。.</p>
<p>访问者是一个用于 AST 遍历的跨语言的模式。 简单的说它们就是一个对象，定义了用于在一个树状结构中获取具体节点的方法。 这么说有些抽象所以让我们来看一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MyVisitor = &#123;</div><div class="line">  Identifier() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Called!"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 你也可以先创建一个访问者对象，并在稍后给它添加方法。</span></div><div class="line"><span class="keyword">let</span> visitor = &#123;&#125;;</div><div class="line">visitor.MemberExpression = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">visitor.FunctionDeclaration = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>： <code>Identifier() { ... }</code> 是 <code>Identifier: { enter() { ... } }</code> 的简写形式。.</p>
</blockquote>
<p>这是一个简单的访问者，把它用于遍历中时，每当在树中遇见一个 <code>Identifier</code> 的时候会调用 <code>Identifier()</code> 方法。</p>
<p>所以在下面的代码中 <code>Identifier()</code> 方法会被调用四次（包括 <code>square</code> 在内，总共有四个 <code>Identifier</code>）。).</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">path.traverse(MyVisitor);</div><div class="line">Called!</div><div class="line">Called!</div><div class="line">Called!</div><div class="line">Called!</div></pre></td></tr></table></figure>
<p>这些调用都发生在<strong>进入</strong>节点时，不过有时候我们也可以在<strong>退出</strong>时调用访问者方法。.</p>
<p>假设我们有一个树状结构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- FunctionDeclaration</div><div class="line">  - Identifier (id)</div><div class="line">  - Identifier (params[<span class="number">0</span>])</div><div class="line">  - BlockStatement (body)</div><div class="line">    - ReturnStatement (body)</div><div class="line">      - BinaryExpression (argument)</div><div class="line">        - Identifier (left)</div><div class="line">        - Identifier (right)</div></pre></td></tr></table></figure>
<p>当我们向下遍历这颗树的每一个分支时我们最终会走到尽头，于是我们需要往上遍历回去从而获取到下一个节点。 向下遍历这棵树我们<strong>进入</strong>每个节点，向上遍历回去时我们<strong>退出</strong>每个节点。</p>
<p>让我们以上面那棵树为例子走一遍这个过程。</p>
<ul>
<li>进入 <code>FunctionDeclaration</code> <ul>
<li>进入 <code>Identifier (id)</code></li>
<li>走到尽头</li>
<li>退出 <code>Identifier (id)</code></li>
<li>进入 <code>Identifier (params[0])</code></li>
<li>走到尽头</li>
<li>退出 <code>Identifier (params[0])</code></li>
<li>进入 <code>BlockStatement (body)</code></li>
<li>进入 <code>ReturnStatement (body)</code> <ul>
<li>进入 <code>BinaryExpression (argument)</code></li>
<li>进入 <code>Identifier (left)</code> <ul>
<li>走到尽头</li>
</ul>
</li>
<li>退出 <code>Identifier (left)</code></li>
<li>进入 <code>Identifier (right)</code> <ul>
<li>走到尽头</li>
</ul>
</li>
<li>退出 <code>Identifier (right)</code></li>
<li>退出 <code>BinaryExpression (argument)</code></li>
</ul>
</li>
<li>退出 <code>ReturnStatement (body)</code></li>
<li>退出 <code>BlockStatement (body)</code></li>
</ul>
</li>
<li>退出 <code>FunctionDeclaration</code></li>
</ul>
<p>所以当创建访问者时你实际上有两次机会来访问一个节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MyVisitor = &#123;</div><div class="line">  <span class="attr">Identifier</span>: &#123;</div><div class="line">    enter() &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"Entered!"</span>);</div><div class="line">    &#125;,</div><div class="line">    exit() &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"Exited!"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如有必要，你还可以把方法名用<code>|</code>分割成<code>Idenfifier |MemberExpression</code>形式的字符串，把同一个函数应用到多种访问节点。.</p>
<p>在<a href="https://github.com/babel/babel/blob/2b6ff53459d97218b0cf16f8a51c14a165db1fd2/packages/babel-plugin-transform-flow-comments/src/index.js#L47" target="_blank" rel="external">flow-comments</a> 插件中的例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MyVisitor = &#123;</div><div class="line">  <span class="string">"ExportNamedDeclaration|Flow"</span>(path) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>你也可以在访问者中使用别名(如<a href="https://github.com/babel/babel/tree/master/packages/babel-types/src/definitions" target="_blank" rel="external">babel-types</a>定义).</p>
<p>例如，</p>
<p><code>Function</code> is an alias for <code>FunctionDeclaration</code>, <code>FunctionExpression</code>, <code>ArrowFunctionExpression</code>, <code>ObjectMethod</code> and <code>ClassMethod</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MyVisitor = &#123;</div><div class="line">  <span class="built_in">Function</span>(path) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Paths（路径）"><a href="#Paths（路径）" class="headerlink" title="Paths（路径）"></a><a id="toc-paths"></a>Paths（路径）</h3><p>AST 通常会有许多节点，那么节点直接如何相互关联呢？ 我们可以使用一个可操作和访问的巨大可变对象表示节点之间的关联关系，或者也可以用<strong>Paths</strong>（路径）来简化这件事情。.</p>
<p><strong>Path</strong> 是表示两个节点之间连接的对象。</p>
<p>例如，如果有下面这样一个节点及其子节点︰</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">"FunctionDeclaration"</span>,</div><div class="line">  <span class="attr">id</span>: &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">"square"</span></div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将子节点 <code>Identifier</code> 表示为一个路径（Path）的话，看起来是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"parent"</span>: &#123;</div><div class="line">    <span class="string">"type"</span>: <span class="string">"FunctionDeclaration"</span>,</div><div class="line">    <span class="string">"id"</span>: &#123;...&#125;,</div><div class="line">    ....</div><div class="line">  &#125;,</div><div class="line">  <span class="string">"node"</span>: &#123;</div><div class="line">    <span class="string">"type"</span>: <span class="string">"Identifier"</span>,</div><div class="line">    <span class="string">"name"</span>: <span class="string">"square"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时它还包含关于该路径的其他元数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"parent"</span>: &#123;...&#125;,</div><div class="line">  <span class="string">"node"</span>: &#123;...&#125;,</div><div class="line">  <span class="string">"hub"</span>: &#123;...&#125;,</div><div class="line">  <span class="string">"contexts"</span>: [],</div><div class="line">  <span class="string">"data"</span>: &#123;&#125;,</div><div class="line">  <span class="string">"shouldSkip"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="string">"shouldStop"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="string">"removed"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="string">"state"</span>: <span class="literal">null</span>,</div><div class="line">  <span class="string">"opts"</span>: <span class="literal">null</span>,</div><div class="line">  <span class="string">"skipKeys"</span>: <span class="literal">null</span>,</div><div class="line">  <span class="string">"parentPath"</span>: <span class="literal">null</span>,</div><div class="line">  <span class="string">"context"</span>: <span class="literal">null</span>,</div><div class="line">  <span class="string">"container"</span>: <span class="literal">null</span>,</div><div class="line">  <span class="string">"listKey"</span>: <span class="literal">null</span>,</div><div class="line">  <span class="string">"inList"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="string">"parentKey"</span>: <span class="literal">null</span>,</div><div class="line">  <span class="string">"key"</span>: <span class="literal">null</span>,</div><div class="line">  <span class="string">"scope"</span>: <span class="literal">null</span>,</div><div class="line">  <span class="string">"type"</span>: <span class="literal">null</span>,</div><div class="line">  <span class="string">"typeAnnotation"</span>: <span class="literal">null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然路径对象还包含添加、更新、移动和删除节点有关的其他很多方法，稍后我们再来看这些方法。</p>
<p>在某种意义上，路径是一个节点在树中的位置以及关于该节点各种信息的响应式 <strong>Reactive</strong> 表示。 当你调用一个修改树的方法后，路径信息也会被更新。 Babel 帮你管理这一切，从而使得节点操作简单，尽可能做到无状态。</p>
<h4 id="Paths-in-Visitors（存在于访问者中的路径）"><a href="#Paths-in-Visitors（存在于访问者中的路径）" class="headerlink" title="Paths in Visitors（存在于访问者中的路径）"></a><a id="toc-paths-in-visitors"></a>Paths in Visitors（存在于访问者中的路径）</h4><p>当你有一个 <code>Identifier()</code> 成员方法的访问者时，你实际上是在访问路径而非节点。 通过这种方式，你操作的就是节点的响应式表示（译注：即路径）而非节点本身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MyVisitor = &#123;</div><div class="line">  Identifier(path) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Visiting: "</span> + path.node.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a + b + c;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">path.traverse(MyVisitor);</div><div class="line">Visiting: a</div><div class="line">Visiting: b</div><div class="line">Visiting: c</div></pre></td></tr></table></figure>
<h3 id="State（状态）"><a href="#State（状态）" class="headerlink" title="State（状态）"></a><a id="toc-state"></a>State（状态）</h3><p>状态是抽象语法树AST转换的敌人，状态管理会不断牵扯你的精力，而且几乎所有你对状态的假设，总是会有一些未考虑到的语法最终证明你的假设是错误的。</p>
<p>考虑下列代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>让我们写一个把 <code>n</code> 重命名为 <code>x</code> 的访问者的快速实现.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> paramName;</div><div class="line"></div><div class="line"><span class="keyword">const</span> MyVisitor = &#123;</div><div class="line">  FunctionDeclaration(path) &#123;</div><div class="line">    <span class="keyword">const</span> param = path.node.params[<span class="number">0</span>];</div><div class="line">    paramName = param.name;</div><div class="line">    param.name = <span class="string">"x"</span>;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  Identifier(path) &#123;</div><div class="line">    <span class="keyword">if</span> (path.node.name === paramName) &#123;</div><div class="line">      path.node.name = <span class="string">"x"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>对上面的例子代码这段访问者代码也许能工作，但它很容易被打破：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n;</div><div class="line">&#125;</div><div class="line">n;</div></pre></td></tr></table></figure>
<p>更好的处理方式是使用递归，下面让我们来像克里斯托佛·诺兰的电影盗梦空间那样来把一个访问者放进另外一个访问者里面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> updateParamNameVisitor = &#123;</div><div class="line">  Identifier(path) &#123;</div><div class="line">    <span class="keyword">if</span> (path.node.name === <span class="keyword">this</span>.paramName) &#123;</div><div class="line">      path.node.name = <span class="string">"x"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> MyVisitor = &#123;</div><div class="line">  FunctionDeclaration(path) &#123;</div><div class="line">    <span class="keyword">const</span> param = path.node.params[<span class="number">0</span>];</div><div class="line">    <span class="keyword">const</span> paramName = param.name;</div><div class="line">    param.name = <span class="string">"x"</span>;</div><div class="line"></div><div class="line">    path.traverse(updateParamNameVisitor, &#123; paramName &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">path.traverse(MyVisitor);</div></pre></td></tr></table></figure>
<p>当然，这只是一个刻意编写的例子，不过它演示了如何从访问者中消除全局状态。</p>
<h3 id="Scopes（作用域）"><a href="#Scopes（作用域）" class="headerlink" title="Scopes（作用域）"></a><a id="toc-scopes"></a>Scopes（作用域）</h3><p>接下来让我们介绍<a href="https://en.wikipedia.org/wiki/Scope_(computer_science" target="_blank" rel="external"><strong>作用域（scope）</strong></a>)的概念。 JavaScript 支持<a href="https://en.wikipedia.org/wiki/Scope_(computer_science" target="_blank" rel="external">词法作用域</a>#Lexical_scoping_vs._dynamic_scoping)，在树状嵌套结构中代码块创建出新的作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// global scope</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">scopeOne</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// scope 1</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">scopeTwo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// scope 2</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 JavaScript 中，每当你创建了一个引用，不管是通过变量（variable）、函数（function）、类型（class）、参数（params）、模块导入（import）还是标签（label）等，它都属于当前作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> global = <span class="string">"I am in the global scope"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">scopeOne</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> one = <span class="string">"I am in the scope created by `scopeOne()`"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">scopeTwo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> two = <span class="string">"I am in the scope created by `scopeTwo()`"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更深的内部作用域代码可以使用外层作用域中的引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">scopeOne</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> one = <span class="string">"I am in the scope created by `scopeOne()`"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">scopeTwo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    one = <span class="string">"I am updating the reference in `scopeOne` inside `scopeTwo`"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内层作用域也可以创建和外层作用域同名的引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">scopeOne</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> one = <span class="string">"I am in the scope created by `scopeOne()`"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">scopeTwo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> one = <span class="string">"I am creating a new `one` but leaving reference in `scopeOne()` alone."</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当编写一个转换时，必须小心作用域。我们得确保在改变代码的各个部分时不会破坏已经存在的代码。</p>
<p>我们在添加一个新的引用时需要确保新增加的引用名字和已有的所有引用不冲突。 或者我们仅仅想找出使用一个变量的所有引用， 我们只想在给定的作用域（Scope）中找出这些引用。</p>
<p>作用域可以被表示为如下形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">path</span>: path,</div><div class="line">  <span class="attr">block</span>: path.node,</div><div class="line">  <span class="attr">parentBlock</span>: path.parent,</div><div class="line">  <span class="attr">parent</span>: parentScope,</div><div class="line">  <span class="attr">bindings</span>: [...]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当你创建一个新的作用域时，需要给出它的路径和父作用域，之后在遍历过程中它会在该作用域内收集所有的引用(“绑定”)。</p>
<p>一旦引用收集完毕，你就可以在作用域（Scopes）上使用各种方法，稍后我们会了解这些方法。</p>
<h4 id="Bindings（绑定）"><a href="#Bindings（绑定）" class="headerlink" title="Bindings（绑定）"></a><a id="toc-bindings"></a>Bindings（绑定）</h4><p>所有引用属于特定的作用域，引用和作用域的这种关系被称作：<strong>绑定（binding）</strong>。.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">scopeOnce</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ref = <span class="string">"This is a binding"</span>;</div><div class="line"></div><div class="line">  ref; <span class="comment">// This is a reference to a binding</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">scopeTwo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    ref; <span class="comment">// This is a reference to a binding from a lower scope</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>单个绑定看起来像这样︰</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Text <span class="keyword">for</span> Translation</div><div class="line">&#123;</div><div class="line">  <span class="attr">identifier</span>: node,</div><div class="line">  <span class="attr">scope</span>: scope,</div><div class="line">  <span class="attr">path</span>: path,</div><div class="line">  <span class="attr">kind</span>: <span class="string">'var'</span>,</div><div class="line"></div><div class="line">  <span class="attr">referenced</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">references</span>: <span class="number">3</span>,</div><div class="line">  <span class="attr">referencePaths</span>: [path, path, path],</div><div class="line"></div><div class="line">  <span class="attr">constant</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">constantViolations</span>: [path]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了这些信息你就可以查找一个绑定的所有引用，并且知道这是什么类型的绑定(参数，定义等等)，查找它所属的作用域，或者拷贝它的标识符。 你甚至可以知道它是不是常量，如果不是，那么是哪个路径修改了它。</p>
<p>在很多情况下，知道一个绑定是否是常量非常有用，最有用的一种情形就是代码压缩时。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">scopeOne</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ref1 = <span class="string">"This is a constant binding"</span>;</div><div class="line"></div><div class="line">  becauseNothingEverChangesTheValueOf(ref1);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">scopeTwo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ref2 = <span class="string">"This is *not* a constant binding"</span>;</div><div class="line">    ref2 = <span class="string">"Because this changes the value"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a><a id="toc-api"></a>API</h1><p>Babel 实际上是一组模块的集合。本节我们将探索一些主要的模块，解释它们是做什么的以及如何使用它们。</p>
<blockquote>
<p>注意：本节内容不是详细的 API 文档的替代品，正式的 API 文档将很快提供出来。</p>
</blockquote>
<h2 id="babylon"><a href="#babylon" class="headerlink" title="babylon"></a><a id="toc-babylon"></a><a href="https://github.com/babel/babylon" target="_blank" rel="external"><code>babylon</code></a></h2><p>Babylon 是 Babel 的解析器。最初是 从Acorn项目fork出来的。Acorn非常快，易于使用，并且针对非标准特性(以及那些未来的标准特性) 设计了一个基于插件的架构。</p>
<p>首先，让我们安装它。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save babylon</div></pre></td></tr></table></figure>
<p>先从解析一个代码字符串开始：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babylon <span class="keyword">from</span> <span class="string">"babylon"</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> code = <span class="string">`function square(n) &#123;</span></div><div class="line">  return n * n;</div><div class="line">&#125;`;</div><div class="line"></div><div class="line">babylon.parse(code);</div><div class="line"><span class="comment">// Node &#123;</span></div><div class="line"><span class="comment">//   type: "File",</span></div><div class="line"><span class="comment">//   start: 0,</span></div><div class="line"><span class="comment">//   end: 38,</span></div><div class="line"><span class="comment">//   loc: SourceLocation &#123;...&#125;,</span></div><div class="line"><span class="comment">//   program: Node &#123;...&#125;,</span></div><div class="line"><span class="comment">//   comments: [],</span></div><div class="line"><span class="comment">//   tokens: [...]</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure>
<p>我们还能像下面这样传递选项给 <code>parse()</code>方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">babylon.parse(code, &#123;</div><div class="line">  <span class="attr">sourceType</span>: <span class="string">"module"</span>, <span class="comment">// default: "script"</span></div><div class="line">  plugins: [<span class="string">"jsx"</span>] <span class="comment">// default: []</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>sourceType</code> 可以是 <code>&quot;module&quot;</code> 或者 <code>&quot;script&quot;</code>，它表示 Babylon 应该用哪种模式来解析。 <code>&quot;module&quot;</code> 将会在严格模式下解析并且允许模块定义，<code>&quot;script&quot;</code> 则不会。</p>
<blockquote>
<p><strong>注意：</strong> <code>sourceType</code> 的默认值是 <code>&quot;script&quot;</code> 并且在发现 <code>import</code> 或 <code>export</code> 时产生错误。 使用 <code>scourceType: &quot;module&quot;</code> 来避免这些错误。</p>
</blockquote>
<p>由于 Babylon 使用了基于插件的架构，因此有一个 <code>plugins</code> 选项可以开关内置的插件。 注意 Babylon 尚未对外部插件开放此 API 接口，不排除未来会开放此API。</p>
<p>要查看完整的插件列表，请参见 <a href="https://github.com/babel/babylon/blob/master/README.md#plugins" target="_blank" rel="external">Babylon README</a>文件。.</p>
<h2 id="babel-traverse"><a href="#babel-traverse" class="headerlink" title="babel-traverse"></a><a id="toc-babel-traverse"></a><a href="https://github.com/babel/babel/tree/master/packages/babel-traverse" target="_blank" rel="external"><code>babel-traverse</code></a></h2><p>Babel Traverse（遍历）模块维护了整棵树的状态，并且负责替换、移除和添加节点。</p>
<p>运行以下命令安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save babel-traverse</div></pre></td></tr></table></figure>
<p>我们可以和 Babylon 一起使用来遍历和更新节点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babylon <span class="keyword">from</span> <span class="string">"babylon"</span>;</div><div class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">"babel-traverse"</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> code = <span class="string">`function square(n) &#123;</span></div><div class="line">  return n * n;</div><div class="line">&#125;`;</div><div class="line"></div><div class="line"><span class="keyword">const</span> ast = babylon.parse(code);</div><div class="line"></div><div class="line">traverse(ast, &#123;</div><div class="line">  enter(path) &#123;</div><div class="line">    <span class="keyword">if</span> (</div><div class="line">      path.node.type === <span class="string">"Identifier"</span> &amp;&amp;</div><div class="line">      path.node.name === <span class="string">"n"</span></div><div class="line">    ) &#123;</div><div class="line">      path.node.name = <span class="string">"x"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="babel-types"><a href="#babel-types" class="headerlink" title="babel-types"></a><a id="toc-babel-types"></a><a href="https://github.com/babel/babel/tree/master/packages/babel-types" target="_blank" rel="external"><code>babel-types</code></a></h2><p>Babel Types模块是一个用于 AST 节点的 Lodash 式工具库（译注：Lodash 是一个 JavaScript 函数工具库，提供了基于函数式编程风格的众多工具函数）， 它包含了构造、验证以及变换 AST 节点的方法。 该工具库包含考虑周到的工具方法，对编写处理AST逻辑非常有用。</p>
<p>可以运行以下命令来安装它：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save babel-types</div></pre></td></tr></table></figure>
<p>然后按如下所示来使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">"babel-traverse"</span>;</div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">"babel-types"</span>;</div><div class="line"></div><div class="line">traverse(ast, &#123;</div><div class="line">  enter(path) &#123;</div><div class="line">    <span class="keyword">if</span> (t.isIdentifier(path.node, &#123; <span class="attr">name</span>: <span class="string">"n"</span> &#125;)) &#123;</div><div class="line">      path.node.name = <span class="string">"x"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Definitions（定义）"><a href="#Definitions（定义）" class="headerlink" title="Definitions（定义）"></a><a id="toc-definitions"></a>Definitions（定义）</h3><p>Babel Types模块拥有每一个单一类型节点的定义，包括节点包含哪些属性，什么是合法值，如何构建节点、遍历节点，以及节点的别名等信息。</p>
<p>单一节点类型的定义形式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">defineType(<span class="string">"BinaryExpression"</span>, &#123;</div><div class="line">  <span class="attr">builder</span>: [<span class="string">"operator"</span>, <span class="string">"left"</span>, <span class="string">"right"</span>],</div><div class="line">  <span class="attr">fields</span>: &#123;</div><div class="line">    <span class="attr">operator</span>: &#123;</div><div class="line">      <span class="attr">validate</span>: assertValueType(<span class="string">"string"</span>)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">left</span>: &#123;</div><div class="line">      <span class="attr">validate</span>: assertNodeType(<span class="string">"Expression"</span>)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">right</span>: &#123;</div><div class="line">      <span class="attr">validate</span>: assertNodeType(<span class="string">"Expression"</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">visitor</span>: [<span class="string">"left"</span>, <span class="string">"right"</span>],</div><div class="line">  <span class="attr">aliases</span>: [<span class="string">"Binary"</span>, <span class="string">"Expression"</span>]</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Builders（构建器）"><a href="#Builders（构建器）" class="headerlink" title="Builders（构建器）"></a><a id="toc-builders"></a>Builders（构建器）</h3><p>你会注意到上面的 <code>BinaryExpression</code> 定义有一个 <code>builder</code> 字段。.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">builder: [<span class="string">"operator"</span>, <span class="string">"left"</span>, <span class="string">"right"</span>]</div></pre></td></tr></table></figure>
<p>这是由于每一个节点类型都有构造器方法builder，按类似下面的方式使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">t.binaryExpression(<span class="string">"*"</span>, t.identifier(<span class="string">"a"</span>), t.identifier(<span class="string">"b"</span>));</div></pre></td></tr></table></figure>
<p>可以创建如下所示的 AST：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">"BinaryExpression"</span>,</div><div class="line">  <span class="attr">operator</span>: <span class="string">"*"</span>,</div><div class="line">  <span class="attr">left</span>: &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">"a"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">right</span>: &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">"b"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当打印出来之后是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a * b</div></pre></td></tr></table></figure>
<p>构造器还会验证自身创建的节点，并在错误使用的情形下会抛出描述性错误，这就引出了下一个方法类型。</p>
<h3 id="Validators（验证器）"><a href="#Validators（验证器）" class="headerlink" title="Validators（验证器）"></a><a id="toc-validators"></a>Validators（验证器）</h3><p><code>BinaryExpression</code> 的定义还包含了节点的字段 <code>fields</code> 信息，以及如何验证这些字段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">fields: &#123;</div><div class="line">  <span class="attr">operator</span>: &#123;</div><div class="line">    <span class="attr">validate</span>: assertValueType(<span class="string">"string"</span>)</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">left</span>: &#123;</div><div class="line">    <span class="attr">validate</span>: assertNodeType(<span class="string">"Expression"</span>)</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">right</span>: &#123;</div><div class="line">    <span class="attr">validate</span>: assertNodeType(<span class="string">"Expression"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以创建两种验证方法。第一种是 <code>isX</code>。.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">t.isBinaryExpression(maybeBinaryExpressionNode);</div></pre></td></tr></table></figure>
<p>这个测试用来确保节点是一个二进制表达式，另外你也可以传入第二个参数来确保节点包含特定的属性和值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">t.isBinaryExpression(maybeBinaryExpressionNode, &#123; <span class="attr">operator</span>: <span class="string">"*"</span> &#125;);</div></pre></td></tr></table></figure>
<p>这些方法还有一种断言式的版本，会抛出异常而不是返回 <code>true</code> 或 <code>false</code>。.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">t.assertBinaryExpression(maybeBinaryExpressionNode);</div><div class="line">t.assertBinaryExpression(maybeBinaryExpressionNode, &#123; <span class="attr">operator</span>: <span class="string">"*"</span> &#125;);</div><div class="line"><span class="comment">// Error: Expected type "BinaryExpression" with option &#123; "operator": "*" &#125;</span></div></pre></td></tr></table></figure>
<h3 id="Converters（变换器）"><a href="#Converters（变换器）" class="headerlink" title="Converters（变换器）"></a><a id="toc-converters"></a>Converters（变换器）</h3><blockquote>
<p>[WIP]</p>
</blockquote>
<h2 id="babel-generator"><a href="#babel-generator" class="headerlink" title="babel-generator"></a><a id="toc-babel-generator"></a><a href="https://github.com/babel/babel/tree/master/packages/babel-generator" target="_blank" rel="external"><code>babel-generator</code></a></h2><p>Babel Generator模块是 Babel 的代码生成器，它读取AST并将其转换为代码和源码映射（sourcemaps）。</p>
<p>运行以下命令来安装它：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save babel-generator</div></pre></td></tr></table></figure>
<p>然后按如下方式使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babylon <span class="keyword">from</span> <span class="string">"babylon"</span>;</div><div class="line"><span class="keyword">import</span> generate <span class="keyword">from</span> <span class="string">"babel-generator"</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> code = <span class="string">`function square(n) &#123;</span></div><div class="line">  return n * n;</div><div class="line">&#125;`;</div><div class="line"></div><div class="line"><span class="keyword">const</span> ast = babylon.parse(code);</div><div class="line"></div><div class="line">generate(ast, &#123;&#125;, code);</div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">//   code: "...",</span></div><div class="line"><span class="comment">//   map: "..."</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure>
<p>你也可以给 <code>generate()</code> 方法传递选项。.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">generate(ast, &#123;</div><div class="line">  <span class="attr">retainLines</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">compact</span>: <span class="string">"auto"</span>,</div><div class="line">  <span class="attr">concise</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">quotes</span>: <span class="string">"double"</span>,</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;, code);</div></pre></td></tr></table></figure>
<h2 id="babel-template"><a href="#babel-template" class="headerlink" title="babel-template"></a><a id="toc-babel-template"></a><a href="https://github.com/babel/babel/tree/master/packages/babel-template" target="_blank" rel="external"><code>babel-template</code></a></h2><p>babel-template 是另一个虽然很小但却非常有用的模块。 它能让你编写字符串形式且带有占位符的代码来代替手动编码， 尤其是生成的大规模 AST的时候。 在计算机科学中，这种能力被称为准引用（quasiquotes）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save babel-template</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> template <span class="keyword">from</span> <span class="string">"babel-template"</span>;</div><div class="line"><span class="keyword">import</span> generate <span class="keyword">from</span> <span class="string">"babel-generator"</span>;</div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">"babel-types"</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> buildRequire = template(<span class="string">`</span></div><div class="line">  var IMPORT_NAME = require(SOURCE);</div><div class="line">`);</div><div class="line"></div><div class="line"><span class="keyword">const</span> ast = buildRequire(&#123;</div><div class="line">  <span class="attr">IMPORT_NAME</span>: t.identifier(<span class="string">"myModule"</span>),</div><div class="line">  <span class="attr">SOURCE</span>: t.stringLiteral(<span class="string">"my-module"</span>)</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(generate(ast).code);</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myModule = <span class="built_in">require</span>(<span class="string">"my-module"</span>);</div></pre></td></tr></table></figure>
<h1 id="编写你的第一个-Babel-插件"><a href="#编写你的第一个-Babel-插件" class="headerlink" title="编写你的第一个 Babel 插件"></a><a id="toc-writing-your-first-babel-plugin"></a>编写你的第一个 Babel 插件</h1><p>现在你已经熟悉了 Babel 的所有基础知识了，让我们把这些知识和插件的 API融合在一起来编写第一个 Babel 插件吧。</p>
<p>先从一个接收了当前<code>babel</code>对象作为参数的 <a href="https://github.com/babel/babel/tree/master/packages/babel-core" target="_blank" rel="external"><code>function</code></a> 开始。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">babel</span>) </span>&#123;</div><div class="line">  <span class="comment">// plugin contents</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于你将会经常这样使用，所以直接取出 <code>babel.types</code> 会更方便：（译注：这是 ES2015 语法中的对象解构，即 Destructuring）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) </span>&#123;</div><div class="line">  <span class="comment">// plugin contents</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着返回一个对象，其 <code>visitor</code> 属性是这个插件的主要访问者。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">visitor</span>: &#123;</div><div class="line">      <span class="comment">// visitor contents</span></div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Visitor 中的每个函数接收2个参数：<code>path</code> 和 <code>state</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">visitor</span>: &#123;</div><div class="line">      Identifier(path, state) &#123;&#125;,</div><div class="line">      ASTNodeTypeHere(path, state) &#123;&#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>让我们快速编写一个可用的插件来展示一下它是如何工作的。下面是我们的源代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo === bar;</div></pre></td></tr></table></figure>
<p>其 AST 形式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">"BinaryExpression"</span>,</div><div class="line">  <span class="attr">operator</span>: <span class="string">"==="</span>,</div><div class="line">  <span class="attr">left</span>: &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">"foo"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">right</span>: &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">"bar"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们从添加 <code>BinaryExpression</code> 访问者方法开始：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">visitor</span>: &#123;</div><div class="line">      BinaryExpression(path) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们更确切一些，只关注哪些使用了 <code>===</code> 的 <code>BinaryExpression</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">visitor: &#123;</div><div class="line">  BinaryExpression(path) &#123;</div><div class="line">    <span class="keyword">if</span> (path.node.operator !== <span class="string">"==="</span>) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们用新的标识符来替换 <code>left</code> 属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">BinaryExpression(path) &#123;</div><div class="line">  <span class="keyword">if</span> (path.node.operator !== <span class="string">"==="</span>) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  path.node.left = t.identifier(<span class="string">"sebmck"</span>);</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>于是如果我们运行这个插件我们会得到：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sebmck === bar;</div></pre></td></tr></table></figure>
<p>现在只需要替换 <code>right</code> 属性了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">BinaryExpression(path) &#123;</div><div class="line">  <span class="keyword">if</span> (path.node.operator !== <span class="string">"==="</span>) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  path.node.left = t.identifier(<span class="string">"sebmck"</span>);</div><div class="line">  path.node.right = t.identifier(<span class="string">"dork"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是我们的最终结果了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sebmck === dork;</div></pre></td></tr></table></figure>
<p>完美！我们的第一个 Babel 插件。</p>
<hr>
<h1 id="转换操作"><a href="#转换操作" class="headerlink" title="转换操作"></a><a id="toc-transformation-operations"></a>转换操作</h1><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a><a id="toc-visiting"></a>访问</h2><h3 id="获取子节点的Path"><a href="#获取子节点的Path" class="headerlink" title="获取子节点的Path"></a><a id="toc-get-the-path-of-a-sub-node"></a>获取子节点的Path</h3><p>为了得到一个AST节点的属性值，我们一般先访问到该节点，然后利用 <code>path.node.property</code> 方法即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// the BinaryExpression AST node has properties: `left`, `right`, `operator`</span></div><div class="line">BinaryExpression(path) &#123;</div><div class="line">  path.node.left;</div><div class="line">  path.node.right;</div><div class="line">  path.node.operator;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你想访问到该属性内部的<code>path</code>，使用path对象的<code>get</code>方法，传递该属性的字符串形式作为参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">BinaryExpression(path) &#123;</div><div class="line">  path.get(<span class="string">'left'</span>);</div><div class="line">&#125;</div><div class="line">Program(path) &#123;</div><div class="line">  path.get(<span class="string">'body.0'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="检查节点的类型"><a href="#检查节点的类型" class="headerlink" title="检查节点的类型"></a><a id="toc-check-if-a-node-is-a-certain-type"></a>检查节点的类型</h3><p>如果你想检查节点的类型，最好的方式是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BinaryExpression(path) &#123;</div><div class="line">  <span class="keyword">if</span> (t.isIdentifier(path.node.left)) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你同样可以对节点的属性们做浅层检查：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BinaryExpression(path) &#123;</div><div class="line">  <span class="keyword">if</span> (t.isIdentifier(path.node.left, &#123; <span class="attr">name</span>: <span class="string">"n"</span> &#125;)) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>功能上等价于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">BinaryExpression(path) &#123;</div><div class="line">  <span class="keyword">if</span> (</div><div class="line">    path.node.left != <span class="literal">null</span> &amp;&amp;</div><div class="line">    path.node.left.type === <span class="string">"Identifier"</span> &amp;&amp;</div><div class="line">    path.node.left.name === <span class="string">"n"</span></div><div class="line">  ) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="检查路径（Path）类型"><a href="#检查路径（Path）类型" class="headerlink" title="检查路径（Path）类型"></a><a id="toc-check-if-a-path-is-a-certain-type"></a>检查路径（Path）类型</h3><p>一个路径具有相同的方法检查节点的类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BinaryExpression(path) &#123;</div><div class="line">  <span class="keyword">if</span> (path.get(<span class="string">'left'</span>).isIdentifier(&#123; <span class="attr">name</span>: <span class="string">"n"</span> &#125;)) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就相当于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BinaryExpression(path) &#123;</div><div class="line">  <span class="keyword">if</span> (t.isIdentifier(path.node.left, &#123; <span class="attr">name</span>: <span class="string">"n"</span> &#125;)) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="检查标识符（Identifier）是否被引用"><a href="#检查标识符（Identifier）是否被引用" class="headerlink" title="检查标识符（Identifier）是否被引用"></a><a id="toc-check-if-an-identifier-is-referenced"></a>检查标识符（Identifier）是否被引用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Identifier(path) &#123;</div><div class="line">  <span class="keyword">if</span> (path.isReferencedIdentifier()) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Identifier(path) &#123;</div><div class="line">  <span class="keyword">if</span> (t.isReferenced(path.node, path.parent)) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="找到特定的父路径"><a href="#找到特定的父路径" class="headerlink" title="找到特定的父路径"></a><a id="toc-find-a-specific-parent-path"></a>找到特定的父路径</h3><p>有时你需要从一个路径向上遍历语法树，直到满足相应的条件。</p>
<p>对于每一个父路径调用<code>callback</code>并将其<code>NodePath</code>当作参数，当<code>callback</code>返回真值时，则将其<code>NodePath</code>返回。.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path.findParent(<span class="function">(<span class="params">path</span>) =&gt;</span> path.isObjectExpression());</div></pre></td></tr></table></figure>
<p>如果也需要遍历当前节点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path.find(<span class="function">(<span class="params">path</span>) =&gt;</span> path.isObjectExpression());</div></pre></td></tr></table></figure>
<p>查找最接近的父函数或程序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path.getFunctionParent();</div></pre></td></tr></table></figure>
<p>向上遍历语法树，直到找到在列表中的父节点路径</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path.getStatementParent();</div></pre></td></tr></table></figure>
<h3 id="获取同级路径"><a href="#获取同级路径" class="headerlink" title="获取同级路径"></a><a id="toc-get-sibling-paths"></a>获取同级路径</h3><p>如果一个路径是在一个 <code>Function</code>／<code>Program</code>中的列表里面，它就有同级节点。</p>
<ul>
<li>使用<code>path.inList</code>来判断路径是否有同级节点，</li>
<li>使用<code>path.getSibling(index)</code>来获得同级路径,</li>
<li>使用 <code>path.key</code>获取路径所在容器的索引,</li>
<li>使用 <code>path.container</code>获取路径的容器（包含所有同级节点的数组）</li>
<li>使用 <code>path.listKey</code>获取容器的key</li>
</ul>
<blockquote>
<p>这些API用于 babel-minify &lt;/&gt;中使用的 transform-merge-sibling-variables &lt;/&gt;插件.</p> </blockquote> <p></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>; <span class="comment">// pathA, path.key = 0</span></div><div class="line"><span class="keyword">var</span> b = <span class="number">2</span>; <span class="comment">// pathB, path.key = 1</span></div><div class="line"><span class="keyword">var</span> c = <span class="number">3</span>; <span class="comment">// pathC, path.key = 2</span></div></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">visitor</span>: &#123;</div><div class="line">      VariableDeclaration(path) &#123;</div><div class="line">        <span class="comment">// if the current path is pathA</span></div><div class="line">        path.inList <span class="comment">// true</span></div><div class="line">        path.listKey <span class="comment">// "body"</span></div><div class="line">        path.key <span class="comment">// 0</span></div><div class="line">        path.getSibling(<span class="number">0</span>) <span class="comment">// pathA</span></div><div class="line">        path.getSibling(path.key + <span class="number">1</span>) <span class="comment">// pathB</span></div><div class="line">        path.container <span class="comment">// [pathA, pathB, pathC]</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="停止遍历"><a href="#停止遍历" class="headerlink" title="停止遍历"></a><a id="toc-stopping-traversal"></a>停止遍历</h3><p>如果你的插件需要在某种情况下不运行，最简单的做法是尽早写回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BinaryExpression(path) &#123;</div><div class="line">  <span class="keyword">if</span> (path.node.operator !== <span class="string">'**'</span>) <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果您在顶级路径中进行子遍历，则可以使用2个提供的API方法：</p>
<p><code>path.skip()</code> skips traversing the children of the current path. <code>path.stop()</code> stops traversal entirely.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">outerPath.traverse(&#123;</div><div class="line">  <span class="built_in">Function</span>(innerPath) &#123;</div><div class="line">    innerPath.skip(); <span class="comment">// if checking the children is irrelevant</span></div><div class="line">  &#125;,</div><div class="line">  ReferencedIdentifier(innerPath, state) &#123;</div><div class="line">    state.iife = <span class="literal">true</span>;</div><div class="line">    innerPath.stop(); <span class="comment">// if you want to save some state and then stop traversal, or deopt</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a><a id="toc-manipulation"></a>处理</h2><h3 id="替换一个节点"><a href="#替换一个节点" class="headerlink" title="替换一个节点"></a><a id="toc-replacing-a-node"></a>替换一个节点</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BinaryExpression(path) &#123;</div><div class="line">  path.replaceWith(</div><div class="line">    t.binaryExpression(<span class="string">"**"</span>, path.node.left, t.numberLiteral(<span class="number">2</span>))</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  function square(n) &#123;</div><div class="line"><span class="deletion">-   return n * n;</span></div><div class="line"><span class="addition">+   return n ** 2;</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="用多节点替换单节点"><a href="#用多节点替换单节点" class="headerlink" title="用多节点替换单节点"></a><a id="toc-replacing-a-node-with-multiple-nodes"></a>用多节点替换单节点</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ReturnStatement(path) &#123;</div><div class="line">  path.replaceWithMultiple([</div><div class="line">    t.expressionStatement(t.stringLiteral(<span class="string">"Is this the real life?"</span>)),</div><div class="line">    t.expressionStatement(t.stringLiteral(<span class="string">"Is this just fantasy?"</span>)),</div><div class="line">    t.expressionStatement(t.stringLiteral(<span class="string">"(Enjoy singing the rest of the song in your head)"</span>)),</div><div class="line">  ]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  function square(n) &#123;</div><div class="line"><span class="deletion">-   return n * n;</span></div><div class="line"><span class="addition">+   "Is this the real life?";</span></div><div class="line"><span class="addition">+   "Is this just fantasy?";</span></div><div class="line"><span class="addition">+   "(Enjoy singing the rest of the song in your head)";</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>**注意：&lt;/&gt;当用多个节点替换一个表达式时，它们必须是   声明。 这是因为Babel在更换节点时广泛使用启发式算法，这意味着您可以做一些非常疯狂的转换，否则将会非常冗长。</p> </blockquote> <p></p>
<h3 id="用字符串源码替换节点"><a href="#用字符串源码替换节点" class="headerlink" title="用字符串源码替换节点"></a><a id="toc-replacing-a-node-with-a-source-string"></a>用字符串源码替换节点</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">FunctionDeclaration(path) &#123;</div><div class="line">  path.replaceWithSourceString(<span class="string">`function add(a, b) &#123;</span></div><div class="line">    return a + b;</div><div class="line">  &#125;`);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="deletion">- function square(n) &#123;</span></div><div class="line"><span class="deletion">-   return n * n;</span></div><div class="line"><span class="addition">+ function add(a, b) &#123;</span></div><div class="line"><span class="addition">+   return a + b;</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>**注意：&lt;/&gt;不建议使用这个API，除非您正在处理动态的源码字符串，否则在访问者外部解析代码更有效率。</p> </blockquote> <p></p>
<h3 id="插入兄弟节点"><a href="#插入兄弟节点" class="headerlink" title="插入兄弟节点"></a><a id="toc-inserting-a-sibling-node"></a>插入兄弟节点</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FunctionDeclaration(path) &#123;</div><div class="line">  path.insertBefore(t.expressionStatement(t.stringLiteral(<span class="string">"Because I'm easy come, easy go."</span>)));</div><div class="line">  path.insertAfter(t.expressionStatement(t.stringLiteral(<span class="string">"A little high, little low."</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>

<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="addition">+ "Because I'm easy come, easy go.";</span></div><div class="line">  function square(n) &#123;</div><div class="line">    return n * n;</div><div class="line">  &#125;</div><div class="line"><span class="addition">+ "A little high, little low.";</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：&lt;/&gt;这里同样应该使用声明或者一个声明数组。 这个使用了在用多个节点替换一个节点&lt;/&gt;中提到的相同的启发式算法。.</p> </blockquote> <p></p>
<h3 id="插入到容器（container）中"><a href="#插入到容器（container）中" class="headerlink" title="插入到容器（container）中"></a><a id="toc-inserting-into-a-container"></a>插入到容器（container）中</h3><p>如果您想要在AST节点属性中插入一个像<code>body &lt;/ 0&gt;那样的数组。
它与 &lt;code&gt; insertBefore</code>/<code>insertAfter</code> 类似, 但您必须指定 <code>listKey</code> (通常是 <code>正文</code>).</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ClassMethod(path) &#123;</div><div class="line">  path.get(<span class="string">'body'</span>).unshiftContainer(<span class="string">'body'</span>, t.expressionStatement(t.stringLiteral(<span class="string">'before'</span>)));</div><div class="line">  path.get(<span class="string">'body'</span>).pushContainer(<span class="string">'body'</span>, t.expressionStatement(t.stringLiteral(<span class="string">'after'</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>

<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> class A &#123;</div><div class="line">  constructor() &#123;</div><div class="line"><span class="addition">+   "before"</span></div><div class="line">    var a = 'middle';</div><div class="line"><span class="addition">+   "after"</span></div><div class="line">  &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="删除一个节点"><a href="#删除一个节点" class="headerlink" title="删除一个节点"></a><a id="toc-removing-a-node"></a>删除一个节点</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">FunctionDeclaration(path) &#123;</div><div class="line">  path.remove();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="deletion">- function square(n) &#123;</span></div><div class="line"><span class="deletion">-   return n * n;</span></div><div class="line"><span class="deletion">- &#125;</span></div></pre></td></tr></table></figure>
<h3 id="替换父节点"><a href="#替换父节点" class="headerlink" title="替换父节点"></a><a id="toc-replacing-a-parent"></a>替换父节点</h3><p>只需使用parentPath：` path.parentPath &lt;/&gt;调用<code> replaceWith &lt;/&gt;即可</code></p><p></p>
<pre><code class="js">BinaryExpression(path) {
  path.parentPath.replaceWith(
    t.expressionStatement(t.stringLiteral("Anyway the wind blows, doesn't really matter to me, to me."))
  );
}
`</code></pre> 

<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  function square(n) &#123;</div><div class="line"><span class="deletion">-   return n * n;</span></div><div class="line"><span class="addition">+   "Anyway the wind blows, doesn't really matter to me, to me.";</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="删除父节点"><a href="#删除父节点" class="headerlink" title="删除父节点"></a><a id="toc-removing-a-parent"></a>删除父节点</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BinaryExpression(path) &#123;</div><div class="line">  path.parentPath.remove();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  function square(n) &#123;</div><div class="line"><span class="deletion">-   return n * n;</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="Scope（作用域）"><a href="#Scope（作用域）" class="headerlink" title="Scope（作用域）"></a><a id="toc-scope"></a>Scope（作用域）</h2><h3 id="检查本地变量是否被绑定"><a href="#检查本地变量是否被绑定" class="headerlink" title="检查本地变量是否被绑定"></a><a id="toc-checking-if-a-local-variable-is-bound"></a>检查本地变量是否被绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">FunctionDeclaration(path) &#123;</div><div class="line">  <span class="keyword">if</span> (path.scope.hasBinding(<span class="string">"n"</span>)) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这将遍历范围树并检查特定的绑定。</p>
<p>您也可以检查一个作用域是否有**自己的&lt;/&gt;绑定：</p> <p></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">FunctionDeclaration(path) &#123;</div><div class="line">  <span class="keyword">if</span> (path.scope.hasOwnBinding(<span class="string">"n"</span>)) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="创建一个-UID"><a href="#创建一个-UID" class="headerlink" title="创建一个 UID"></a><a id="toc-generating-a-uid"></a>创建一个 UID</h3><p>这将生成一个标识符，不会与任何本地定义的变量相冲突。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">FunctionDeclaration(path) &#123;</div><div class="line">  path.scope.generateUidIdentifier(<span class="string">"uid"</span>);</div><div class="line">  <span class="comment">// Node &#123; type: "Identifier", name: "_uid" &#125;</span></div><div class="line">  path.scope.generateUidIdentifier(<span class="string">"uid"</span>);</div><div class="line">  <span class="comment">// Node &#123; type: "Identifier", name: "_uid2" &#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="提升变量声明至父级作用域"><a href="#提升变量声明至父级作用域" class="headerlink" title="提升变量声明至父级作用域"></a><a id="toc-pushing-a-variable-declaration-to-a-parent-scope"></a>提升变量声明至父级作用域</h3><p>有时你可能想要推送一个` VariableDeclaration &lt;/&gt;，这样你就可以分配给它。</p><p></p>
<pre><code class="js">FunctionDeclaration(path) {
  const id = path.scope.generateUidIdentifierBasedOnNode(path.node.id);
  path.remove();
  path.scope.parent.push({ id, init: path.node });
}
`</code></pre> 

<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="deletion">- function square(n) &#123;</span></div><div class="line"><span class="addition">+ var _square = function square(n) &#123;</span></div><div class="line">    return n * n;</div><div class="line"><span class="deletion">- &#125;</span></div><div class="line"><span class="addition">+ &#125;;</span></div></pre></td></tr></table></figure>
<h3 id="重命名绑定及其引用"><a href="#重命名绑定及其引用" class="headerlink" title="重命名绑定及其引用"></a><a id="toc-rename-a-binding-and-its-references"></a>重命名绑定及其引用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">FunctionDeclaration(path) &#123;</div><div class="line">  path.scope.rename(<span class="string">"n"</span>, <span class="string">"x"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="deletion">- function square(n) &#123;</span></div><div class="line"><span class="deletion">-   return n * n;</span></div><div class="line"><span class="addition">+ function square(x) &#123;</span></div><div class="line"><span class="addition">+   return x * x;</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>或者，您可以将绑定重命名为生成的唯一标识符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">FunctionDeclaration(path) &#123;</div><div class="line">  path.scope.rename(<span class="string">"n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="deletion">- function square(n) &#123;</span></div><div class="line"><span class="deletion">-   return n * n;</span></div><div class="line"><span class="addition">+ function square(_n) &#123;</span></div><div class="line"><span class="addition">+   return _n * _n;</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="插件选项"><a href="#插件选项" class="headerlink" title="插件选项"></a><a id="toc-plugin-options"></a>插件选项</h1><p>如果您想让您的用户自定义您的Babel插件的行为您可以接受用户可以指定的插件特定选项，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">    [<span class="string">"my-plugin"</span>, &#123;</div><div class="line">      <span class="string">"option1"</span>: <span class="literal">true</span>,</div><div class="line">      <span class="string">"option2"</span>: <span class="literal">false</span></div><div class="line">    &#125;]</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些选项会通过`状态&lt;/&gt;对象传递给插件访问者：</p><p></p>
<pre><code class="js">export default function({ types: t }) {
  return {
    visitor: {
      FunctionDeclaration(path, state) {
        console.log(state.opts);
        // { option1: true, option2: false }
      }
    }
  }
}
`</code></pre> 

<p>这些选项是特定于插件的，您不能访问其他插件中的选项。</p>
<h2 id="插件的准备和收尾工作"><a href="#插件的准备和收尾工作" class="headerlink" title=" 插件的准备和收尾工作"></a><a id="toc-pre-and-post-in-plugins"></a> 插件的准备和收尾工作</h2><p>插件可以具有在插件之前或之后运行的函数。它们可以用于设置或清理/分析目的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    pre(state) &#123;</div><div class="line">      <span class="keyword">this</span>.cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">visitor</span>: &#123;</div><div class="line">      StringLiteral(path) &#123;</div><div class="line">        <span class="keyword">this</span>.cache.set(path.node.value, <span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    post(state) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.cache);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="在插件中启用其他语法"><a href="#在插件中启用其他语法" class="headerlink" title=" 在插件中启用其他语法"></a><a id="toc-enabling-syntax-in-plugins"></a> 在插件中启用其他语法</h2><p>插件可以启用babylon plugins&lt;/&gt;，以便用户不需要安装/启用它们。 这可以防止解析错误，而不会继承语法插件。</p> <p></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">inherits</span>: <span class="built_in">require</span>(<span class="string">"babel-plugin-syntax-jsx"</span>)</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="抛出一个语法错误"><a href="#抛出一个语法错误" class="headerlink" title=" 抛出一个语法错误"></a><a id="toc-throwing-a-syntax-error"></a> 抛出一个语法错误</h2><p>如果您想用babel-code-frame和一个消息抛出一个错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">visitor</span>: &#123;</div><div class="line">      StringLiteral(path) &#123;</div><div class="line">        <span class="keyword">throw</span> path.buildCodeFrameError(<span class="string">"Error message here"</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该错误看起来像：</p>
<pre><code>file.js: Error message here
   7 |
   8 | let tips = [
&gt;  9 |   &quot;Click on any AST node with a &apos;+&apos; to expand it&quot;,
     |   ^
  10 |
  11 |   &quot;Hovering over a node highlights the \
  12 |    corresponding part in the source code&quot;,
</code></pre><hr>
<h1 id="构建节点"><a href="#构建节点" class="headerlink" title="构建节点"></a><a id="toc-building-nodes"></a>构建节点</h1><p>编写转换时，通常需要构建一些要插入的节点进入AST。 如前所述，您可以使用` babel-types &lt;/&gt;包中的<a href="#builders">builder &lt;/&gt;方法。</a></p><p></p>
<p>构建器的方法名称就是您想要的节点类型的名称，除了第一个字母小写。 例如，如果您想建立一个<code> MemberExpression &lt;/&gt;您可以使用<code> t.memberExpression（…）&lt;/&gt;.</code></code></p>

<p>这些构建器的参数由节点定义决定。 有一些正在做的工作，以生成易于阅读的文件定义，但现在他们都可以在<a href="https://github.com/babel/babel/tree/master/packages/babel-types/src/definitions" target="_blank" rel="external">此处</a>找到。.</p>

<p>节点定义如下所示：</p>

<pre><code class="js">defineType("MemberExpression", {
  builder: ["object", "property", "computed"],
  visitor: ["object", "property"],
  aliases: ["Expression", "LVal"],
  fields: {
    object: {
      validate: assertNodeType("Expression")
    },
    property: {
      validate(node, key, val) {
        let expectedType = node.computed ? "Expression" : "Identifier";
        assertNodeType(expectedType)(node, key, val);
      }
    },
    computed: {
      default: false
    }
  }
});
`</code></pre> 

<p>在这里你可以看到关于这个特定节点类型的所有信息，包括如何构建它，遍历它，并验证它。</p>
<p>通过查看 <code>生成器</code> 属性, 可以看到调用生成器方法所需的3个参数 (<code>t. 情况</code>).</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">生成器: [<span class="string">"object"</span>, <span class="string">"property"</span>, <span class="string">"computed"</span>],</div></pre></td></tr></table></figure>
<blockquote>
<p>请注意，有时在节点上可以定制的属性比``构建器&lt;/&gt;数组包含的属性更多。 这是为了防止生成器有太多的参数。 在这些情况下，您需要手动设置属性。 一个例子是<class> ClassMethod &lt;/&gt;.</class></p><br></blockquote><p></p>

<pre><code class="js">// Example
// because the builder doesn't contain `async` as a property
var node = t.classMethod(
  "constructor",
  t.identifier("constructor"),
  params,
  body
)
// set it manually after creation
node.async = true;
``</code></pre> 
> 
> You can see the validation for the builder arguments with the `fields` object.
> 
> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">fields: &#123;</div><div class="line">  <span class="attr">object</span>: &#123;</div><div class="line">    <span class="attr">validate</span>: assertNodeType(<span class="string">"Expression"</span>)</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">property</span>: &#123;</div><div class="line">    validate(node, key, val) &#123;</div><div class="line">      <span class="keyword">let</span> expectedType = node.computed ? <span class="string">"Expression"</span> : <span class="string">"Identifier"</span>;</div><div class="line">      assertNodeType(expectedType)(node, key, val);</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">computed</span>: &#123;</div><div class="line">    <span class="attr">default</span>: <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

You can see that `object` needs to be an `Expression`, `property` either needs to be an `Expression` or an `Identifier` depending on if the member expression is `computed` or not and `computed` is simply a boolean that defaults to `false`.

So we can construct a `MemberExpression` by doing the following:

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">t.memberExpression(</div><div class="line">  t.identifier(<span class="string">'object'</span>),</div><div class="line">  t.identifier(<span class="string">'property'</span>)</div><div class="line">  <span class="comment">// `computed` is optional</span></div><div class="line">);</div></pre></td></tr></table></figure>

Which will result in:

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">object.property</div></pre></td></tr></table></figure>

However, we said that `object` needed to be an `Expression` so why is `Identifier` valid?

Well if we look at the definition of `Identifier` we can see that it has an `aliases` property which states that it is also an expression.

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">aliases: [<span class="string">"Expression"</span>, <span class="string">"LVal"</span>],</div></pre></td></tr></table></figure>

So since `MemberExpression` is a type of `Expression`, we could set it as the `object` of another `MemberExpression`:

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">t.memberExpression(</div><div class="line">  t.memberExpression(</div><div class="line">    t.identifier(<span class="string">'member'</span>),</div><div class="line">    t.identifier(<span class="string">'expression'</span>)</div><div class="line">  ),</div><div class="line">  t.identifier(<span class="string">'property'</span>)</div><div class="line">)</div></pre></td></tr></table></figure>

Which will result in:

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">member.expression.property</div></pre></td></tr></table></figure>

It's very unlikely that you will ever memorize the builder method signatures for every node type. So you should take some time and understand how they are generated from the node definitions.

You can find all of the actual [definitions here](https://github.com/babel/babel/tree/master/packages/babel-types/src/definitions) and you can see them [documented here](https://github.com/babel/babel/blob/master/doc/ast/spec.md)

* * *

# <a id="toc-best-practices"></a>最佳实践

## <a id="toc-create-helper-builders-and-checkers"></a> Create Helper Builders and Checkers

It's pretty simple to extract certain checks (if a node is a certain type) into their own helper functions as well as extracting out helpers for specific node types.

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isAssignment</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> node &amp;&amp; node.operator === opts.operator + <span class="string">"="</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildAssignment</span>(<span class="params">left, right</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> t.assignmentExpression(<span class="string">"="</span>, left, right);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

## <a id="toc-avoid-traversing-the-ast-as-much-as-possible"></a>尽量避免遍历抽象语法树（AST）

Traversing the AST is expensive, and it's easy to accidentally traverse the AST more than necessary. This could be thousands if not tens of thousands of extra operations.

Babel optimizes this as much as possible, merging visitors together if it can in order to do everything in a single traversal.

### <a id="toc-merge-visitors-whenever-possible"></a>及时合并访问者对象

When writing visitors, it may be tempting to call `path.traverse` in multiple places where they are logically necessary.

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">path.traverse(&#123;</div><div class="line">  Identifier(path) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">path.traverse(&#123;</div><div class="line">  BinaryExpression(path) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>

However, it is far better to write these as a single visitor that only gets run once. Otherwise you are traversing the same tree multiple times for no reason.

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">path.traverse(&#123;</div><div class="line">  Identifier(path) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;,</div><div class="line">  BinaryExpression(path) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>

### <a id="toc-do-not-traverse-when-manual-lookup-will-do"></a>可以手动查找就不要遍历

It may also be tempting to call `path.traverse` when looking for a particular node type.

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> nestedVisitor = &#123;</div><div class="line">  Identifier(path) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> MyVisitor = &#123;</div><div class="line">  FunctionDeclaration(path) &#123;</div><div class="line">    path.get(<span class="string">'params'</span>).traverse(nestedVisitor);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>

However, if you are looking for something specific and shallow, there is a good chance you can manually lookup the nodes you need without performing a costly traversal.

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MyVisitor = &#123;</div><div class="line">  FunctionDeclaration(path) &#123;</div><div class="line">    path.node.params.forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>

## <a id="toc-optimizing-nested-visitors"></a>优化嵌套的访问者对象

当您嵌套访问者（visitor）时，把它们嵌套在您的代码中可能是有意义的。

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MyVisitor = &#123;</div><div class="line">  FunctionDeclaration(path) &#123;</div><div class="line">    path.traverse(&#123;</div><div class="line">      Identifier(path) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>

但是，每当调用`FunctionDeclaration()</>时都会创建一个新的访问者对象。 That can be costly, because Babel does some processing each time a new
visitor object is passed in (such as exploding keys containing multiple types,
performing validation, and adjusting the object structure). Because Babel stores
flags on visitor objects indicating that it's already performed that processing,
it's better to store the visitor in a variable and pass the same object each
time.<p></p>

<pre><code class="js">const nestedVisitor = {
  Identifier(path) {
    // ...
  }
};

const MyVisitor = {
  FunctionDeclaration(path) {
    path.traverse(nestedVisitor);
  }
};
`</code></pre> 

<p>如果您在嵌套的访问者中需要一些状态，像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MyVisitor = &#123;</div><div class="line">  FunctionDeclaration(path) &#123;</div><div class="line">    <span class="keyword">var</span> exampleState = path.node.params[<span class="number">0</span>].name;</div><div class="line"></div><div class="line">    path.traverse(&#123;</div><div class="line">      Identifier(path) &#123;</div><div class="line">        <span class="keyword">if</span> (path.node.name === exampleState) &#123;</div><div class="line">          <span class="comment">// ...</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>您可以将它作为状态传递给<code>traverse()&lt;/ 0&gt;方法，并有权访问&lt;code&gt;this</code>在访问者中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> nestedVisitor = &#123;</div><div class="line">  Identifier(path) &#123;</div><div class="line">    <span class="keyword">if</span> (path.node.name === <span class="keyword">this</span>.exampleState) &#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> MyVisitor = &#123;</div><div class="line">  FunctionDeclaration(path) &#123;</div><div class="line">    <span class="keyword">var</span> exampleState = path.node.params[<span class="number">0</span>].name;</div><div class="line">    path.traverse(nestedVisitor, &#123; exampleState &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="留意嵌套结构"><a href="#留意嵌套结构" class="headerlink" title="留意嵌套结构"></a><a id="toc-being-aware-of-nested-structures"></a>留意嵌套结构</h2><p>有时候在考虑给定的转换时，可能会忘记给定的转换结构可以是嵌套的。</p>
<p>例如，想象一下，我们想要查找<code>构造函数</code> <code>ClassMethod</code> <code>Foo</code> <code>ClassDeclaration</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> constructorVisitor = &#123;</div><div class="line">  ClassMethod(path) &#123;</div><div class="line">    <span class="keyword">if</span> (path.node.name === <span class="string">'constructor'</span>) &#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> MyVisitor = &#123;</div><div class="line">  ClassDeclaration(path) &#123;</div><div class="line">    <span class="keyword">if</span> (path.node.id.name === <span class="string">'Foo'</span>) &#123;</div><div class="line">      path.traverse(constructorVisitor);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们忽略了类可以嵌套的事实，使用遍历的话，上面我们也会得到一个嵌套的`构造函数&lt;/&gt;：</p><p></p>
<pre><code class="js">class Foo {
  constructor() {
    class Bar {
      constructor() {
        // ...
      }
    }
  }
}
`</code></pre> 

<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a><a id="toc-unit-testing"></a>单元测试</h2><p>有几种主要的方法来测试babel插件：快照测试，AST测试和执行测试。 对于这个例子，我们将使用 jest &lt;/&gt;，因为它支持盒外快照测试。 我们在这里创建的示例是托管在这个 repo&lt;/&gt;.</p> <p></p>
<p>首先我们需要一个babel插件，我们将把它放在src / index.js中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;br /&gt;<span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">testPlugin</span>(<span class="params">babel</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">visitor</span>: &#123;</div><div class="line">      Identifier(path) &#123;</div><div class="line">        <span class="keyword">if</span> (path.node.name === <span class="string">'foo'</span>) &#123;</div><div class="line">          path.node.name = <span class="string">'bar'</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="快照测试"><a href="#快照测试" class="headerlink" title="快照测试"></a>快照测试</h3><p>接下来，用`` npm install –save-dev babel-core jest &lt;/&gt;安装我们的依赖关系，<br>那么我们可以开始写我们的第一个测试：快照。 快照测试允许我们直观地检查我们的babel插件的输出。 我们给它一个输入，告诉它一个快照，并将其保存到一个文件。 我们检查快照到git中。 这允许我们来看看我们什么时候影响了我们任何试用例子测试的输出。 它也给出了使用差异在拉请求的时候。 当然，您可以用任何测试框架来做到这一点，但是要更新一下快照就像<code>jest -u &lt;/&gt;一样简单.</code></p><p></p>
<pre><code class="js">// src/__tests__/index-test.js
const babel = require('babel-core');
const plugin = require('../');

var example = `
var foo = 1;
if (foo) console.log(foo);
`;

it('works', () => {
  const {code} = babel.transform(example, {plugins: [plugin]});
  expect(code).toMatchSnapshot();
});
``</code></pre> 

<p>这给了我们一个快照文件在`` src / <strong> tests </strong> / <strong> snapshots </strong> / index-test.js.snap &lt;/&gt;.</p><p></p>
<pre><code class="js">exports[`test works 1`] = `
"
var bar = 1;
if (bar) console.log(bar);"
`;
``</code></pre> 

<p>如果我们在插件中将“bar”更改为“baz”并再次运行，则可以得到以下结果：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">接收到的值与存储的快照1不匹配。</div><div class="line"></div><div class="line">    - Snapshot</div><div class="line">    + Received</div><div class="line"></div><div class="line">    @@ -1,3 +1,3 @@</div><div class="line">     "</div><div class="line">    -var bar = 1;</div><div class="line">    -if (bar) console.log(bar);"</div><div class="line">    +var baz = 1;</div><div class="line">    +if (baz) console.log(baz);"</div></pre></td></tr></table></figure>
<p>我们看到我们对插件代码的改变如何影响了我们插件的输出 如果输出看起来不错，我们可以运行`jest -u &lt;/&gt;来更新快照。</p><p></p>
<h3>AST 测试</h3>

<p>除了快照测试外，我们还可以手动检查AST。 这是一个简单但是脆弱的例子。 对于更多涉及的情况，您可能希望利用Babel-遍历。 它允许您用<code>访问者&lt;/&gt;键指定一个对象，就像您使用插件本身。</code></p>

<pre><code class="js">it('contains baz', () => {
  const {ast} = babel.transform(example, {plugins: [plugin]});
  const program = ast.program;
  const declaration = program.body[0].declarations[0];
  assert.equal(declaration.id.name, 'baz');
  // or babelTraverse(program, {visitor: ...})
});
`</code></pre> 

<h3 id="Exec-Tests"><a href="#Exec-Tests" class="headerlink" title="Exec Tests"></a>Exec Tests</h3><p>在这里，我们将转换代码，然后评估它的行为是否正确。 请注意，我们在测试中没有使用``assert&lt;/&gt;。 这确保如果我们的插件做了奇怪的操作，如意外删除断言线，但测试仍然失败。</p><p></p>
<pre><code class="js">it('foo is an alias to baz', () => {
  var input = `
    var foo = 1;
    // test that foo was renamed to baz
    var res = baz;
  `;
  var {code} = babel.transform(input, {plugins: [plugin]});
  var f = new Function(`
    ${code};
    return res;
  `);
  var res = f();
  assert(res === 1, 'res is 1');
});
``</code></pre> 

<p>Babel核心使用类似的方法&lt;/&gt;去获取快照和执行测试。</p> <p></p>
<h3 id="babel-plugin-tester"><a href="#babel-plugin-tester" class="headerlink" title="babel-plugin-tester"></a><a href="https://github.com/kentcdodds/babel-plugin-tester" target="_blank" rel="external"><code>babel-plugin-tester</code></a></h3><p>这个包使测试插件更容易。 如果您熟悉ESLint的<a href="http://eslint.org/docs/developer-guide/working-with-rules#rule-unit-tests" target="_blank" rel="external"> RuleTester</a>您应该对这是熟悉的。 您可以看看<a href="https://github.com/kentcdodds/babel-plugin-tester/blob/master/README.md" target="_blank" rel="external">the docs</a>去充分了解可能的情况，但这里有一个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pluginTester <span class="keyword">from</span> <span class="string">'babel-plugin-tester'</span>;</div><div class="line"><span class="keyword">import</span> identifierReversePlugin <span class="keyword">from</span> <span class="string">'../identifier-reverse-plugin'</span>;</div><div class="line"></div><div class="line">pluginTester(&#123;</div><div class="line">  <span class="attr">plugin</span>: identifierReversePlugin,</div><div class="line">  <span class="attr">fixtures</span>: path.join(__dirname, <span class="string">'__fixtures__'</span>),</div><div class="line">  <span class="attr">tests</span>: &#123;</div><div class="line">    <span class="string">'does not change code with no identifiers'</span>: <span class="string">'"hello";'</span>,</div><div class="line">    <span class="string">'changes this code'</span>: &#123;</div><div class="line">      <span class="attr">code</span>: <span class="string">'var hello = "hi";'</span>,</div><div class="line">      <span class="attr">output</span>: <span class="string">'var olleh = "hi";'</span>,</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'using fixtures files'</span>: &#123;</div><div class="line">      <span class="attr">fixture</span>: <span class="string">'changed.js'</span>,</div><div class="line">      <span class="attr">outputFixture</span>: <span class="string">'changed-output.js'</span>,</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'using jest snapshots'</span>: &#123;</div><div class="line">      <span class="attr">code</span>: <span class="string">`</span></div><div class="line">        function sayHi(person) &#123;</div><div class="line">          return 'Hello ' + person + '!'</div><div class="line">        &#125;</div><div class="line">      `,</div><div class="line">      <span class="attr">snapshot</span>: <span class="literal">true</span>,</div><div class="line">    &#125;,</div><div class="line">  &#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p><em>*</em>对于将来的更新，请跟随 @thejameskyle &lt;/&gt;和 @babeljs &lt;/&gt; 的Twitter。</p> </blockquote><p></p>

]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Babel-插件手册&quot;&gt;&lt;a href=&quot;#Babel-插件手册&quot; class=&quot;headerlink&quot; title=&quot;Babel 插件手册&quot;&gt;&lt;/a&gt;Babel 插件手册&lt;/h1&gt;&lt;p&gt;这篇文档涵盖了如何创建 &lt;a href=&quot;https://babeljs.i
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>svn命令基本使用及原理</title>
    <link href="https://lzm420241.github.io/2018/05/08/svn/"/>
    <id>https://lzm420241.github.io/2018/05/08/svn/</id>
    <published>2018-05-08T11:23:58.000Z</published>
    <updated>2018-05-28T10:55:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="svn常用命令"><a href="#svn常用命令" class="headerlink" title="svn常用命令"></a>svn常用命令</h3><p>1.<strong>将文件checkout到本地目录</strong><br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn checkout path (path是服务器上的目录) 简写：svn co path</div></pre></td></tr></table></figure></p>
<p>2.<strong>切换分支</strong><br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn switch path (path是服务器上的目录) 简写：svn sw path</div></pre></td></tr></table></figure></p>
<p>3.<strong>往版本库添加新文件</strong><br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn add file</div></pre></td></tr></table></figure></p>
<p>4.<strong>将改动的文件提交到版本库</strong><br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svm commit -m <span class="string">"message"</span> [-N][--no-unlock] PATH (如果选择了保持锁，就使用--no-unlock开关) 简写：svn ci -m <span class="string">"message"</span> PATH</div></pre></td></tr></table></figure></p>
<p>5.<strong>加锁／解锁</strong><br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn lock -m <span class="string">"lockMessage"</span> [--force] PATH  svn unlock PATH</div></pre></td></tr></table></figure></p>
<p>6.<strong>更新到某个版本</strong><br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn update -r m path 简写：svn up</div></pre></td></tr></table></figure></p>
<p>7.<strong>查看文件或者目录状态</strong><br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn status [-v (查看文件及子目录状态)] path  简写：svn st</div></pre></td></tr></table></figure></p>
<p>8.<strong>删除文件</strong><br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn delete path -m <span class="string">"message"</span> 简写：svn (del, remove, rm)</div></pre></td></tr></table></figure></p>
<p>9.<strong>查看日志</strong><br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ svn <span class="built_in">log</span> path</div></pre></td></tr></table></figure></p>
<p>10.<strong>查看文件详细信息</strong><br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ svn info path</div></pre></td></tr></table></figure></p>
<p>11.<strong>比较差异</strong><br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn diff path   简写：svn di</div></pre></td></tr></table></figure></p>
<p>12.<strong>将两个版本之间的差异合并到当前文件</strong><br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn merge -r m:n path</div></pre></td></tr></table></figure></p>
<p>13.<strong>将未提交的代码会滚</strong><br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn revert [-R] path</div></pre></td></tr></table></figure></p>
<p>14.<strong>svn帮助</strong><br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn <span class="built_in">log</span> path</div></pre></td></tr></table></figure></p>
<h3 id="svn基本原理"><a href="#svn基本原理" class="headerlink" title="svn基本原理"></a>svn基本原理</h3><p>1.<strong>svn里面三个概念：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.工作拷贝：一个SVN的工作拷贝是用户机器的一个本地目录，保存着一些文件和目录，你可以任意编辑其中的文件，在你提交之前你所做的编辑不会上传到SVN与他人所作的修改进行合并。</div><div class="line"></div><div class="line">2.基准版本：SVN会在每个工作拷贝的一个特定位置保存该工作拷贝最后一次提交时的文件及目录情况，这些文件及目录就称为<span class="string">"基准版本"</span>。</div><div class="line"></div><div class="line">3.Head版本：SVN服务器中的最新版本</div><div class="line"></div><div class="line">注意：如果Head版本比你所编辑的本地工作拷贝版本（指的是基准版本）新的话，而且如果你做了修改，当你Commit的时候会提示有冲突产生，这时你update的时候会将冲突显示出来。如果没有做修改，Commit之后会提示你版本低，需要update成最新版本，此时本地工作拷贝会变成update后的最新的版本。</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;svn常用命令&quot;&gt;&lt;a href=&quot;#svn常用命令&quot; class=&quot;headerlink&quot; title=&quot;svn常用命令&quot;&gt;&lt;/a&gt;svn常用命令&lt;/h3&gt;&lt;p&gt;1.&lt;strong&gt;将文件checkout到本地目录&lt;/strong&gt;&lt;br&gt;    &lt;figure
    
    </summary>
    
      <category term="知识点入门学习" scheme="https://lzm420241.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="svn" scheme="https://lzm420241.github.io/tags/svn/"/>
    
  </entry>
  
  <entry>
    <title>未来6个月的规划</title>
    <link href="https://lzm420241.github.io/2018/04/23/life/2/"/>
    <id>https://lzm420241.github.io/2018/04/23/life/2/</id>
    <published>2018-04-23T07:53:25.000Z</published>
    <updated>2018-04-23T11:40:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2018-Q2-Q3总体规划"><a href="#2018-Q2-Q3总体规划" class="headerlink" title="2018 Q2-Q3总体规划"></a>2018 Q2-Q3总体规划</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">1.用户极致体验</div><div class="line">	要求：</div><div class="line">		1.[页面的流畅性](http://ask.dcloud.net.cn/article/25)</div><div class="line">		2.页面的美观度</div><div class="line">		3.页面的加载性能</div><div class="line">2.前端工具化及工程化</div><div class="line">	发展：</div><div class="line">		1.原始阶段：在原始api方面扩充，将会催生大量的tools</div><div class="line">		2.发展阶段：随着做的东西复杂化，这些需要更多的组织，引入大量设计模式，此时会催生出大量的frameworks</div><div class="line">		3.工程化阶段：随着团队的扩充，就会进入工程化的阶段，各类mvc，mvp，mvvm等设计，可视化开发，自动化测试，团队协作系统等。</div><div class="line">	标准：根据模块化、组件化、规范化、自动化四个来思考，软件工程化关注的是性能、稳定性、可用性、可维护性等方面，一切以这些为目标的工作都是<span class="string">"前端工程化"</span></div><div class="line">	目标：以尽可能快的速度实现可信赖的产品。尽可能短的时间包括开发速度、部署速度与重构速度，而可信赖又在于产品的可测试性、可变性以及Bug的重现与定位</div><div class="line">3.横向发展</div><div class="line">	了解业务发展 -- 了解一些后端的设计</div><div class="line">	了解页面设计原理 --- UI</div><div class="line">	人工智能 -- 前端应用</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;2018-Q2-Q3总体规划&quot;&gt;&lt;a href=&quot;#2018-Q2-Q3总体规划&quot; class=&quot;headerlink&quot; title=&quot;2018 Q2-Q3总体规划&quot;&gt;&lt;/a&gt;2018 Q2-Q3总体规划&lt;/h3&gt;&lt;h4 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot;
    
    </summary>
    
      <category term="生活" scheme="https://lzm420241.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="前端" scheme="https://lzm420241.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="规划" scheme="https://lzm420241.github.io/tags/%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>如何避免感冒及如何处理感冒问题</title>
    <link href="https://lzm420241.github.io/2018/04/23/life/1/"/>
    <id>https://lzm420241.github.io/2018/04/23/life/1/</id>
    <published>2018-04-23T06:13:25.000Z</published>
    <updated>2018-04-23T06:47:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何预防感冒"><a href="#如何预防感冒" class="headerlink" title="如何预防感冒"></a>如何预防感冒</h3><h4 id="感冒的定义"><a href="#感冒的定义" class="headerlink" title="感冒的定义"></a>感冒的定义</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">伤风，又称普通感冒（common cold），医学上还称为急性上呼吸道感染或急性鼻咽炎，是一种上呼吸道的病毒性感染，主要原发于鼻腔，但也可能进犯喉咙以及鼻窦。症状一般于暴露病原后两天内开始出现，包含咳嗽、喉咙痛、流鼻水、打喷嚏、头痛、发烧等。大部分症状通常在七到十天内会缓解，但某些症状可能会持续三个星期以上。有其他健康问题者患感冒时可能会并发肺炎</div></pre></td></tr></table></figure>
<h4 id="如何预防"><a href="#如何预防" class="headerlink" title="如何预防"></a>如何预防</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.勤洗手</div><div class="line">2.勤通风</div><div class="line">3.增强体质</div><div class="line">4.流感疫苗</div></pre></td></tr></table></figure>
<h3 id="如何处理感冒问题"><a href="#如何处理感冒问题" class="headerlink" title="如何处理感冒问题"></a>如何处理感冒问题</h3><h4 id="感冒类型"><a href="#感冒类型" class="headerlink" title="感冒类型"></a>感冒类型</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.风寒型感冒：病人除了有鼻塞、喷嚏、咳嗽、头痛等一般症状外，还有畏寒、低热、无汗、流清涕、吐稀薄白色痰等特点。这种感冒与病人感受风寒有关。治疗应以辛温解表为原则。病人可选用伤风感冒冲剂、感冒清热冲剂、九味羌活丸、通宣理肺丸、午时茶颗粒等药物治疗。若病人兼有内热便秘的症状，可服用防风通圣丸治疗。风寒型感冒病人忌用桑菊感冒片、银翘解毒片、羚翘解毒片、复方感冒片等药物。</div><div class="line">2.风热型感冒：病人除了有鼻塞、流涕、咳嗽、头痛等感冒的一般症状外，还有发热重、痰液粘稠呈黄色等特点。治疗应以辛凉解表为原则。病人可选用感冒退热冲剂、板蓝根冲剂、银翘解毒丸、羚羊解毒丸等药物治疗。风热型感冒病人忌用九味羌活丸、理肺丸等药物。</div><div class="line">3.暑湿型感冒：病人表现为畏寒、发热、口淡无味、头痛、头胀、腹痛、腹泻等症状。此类型感冒多发生在夏季。治疗应以清暑、祛湿、解表为主。病人可选用藿香正气水、银翘解毒丸等药物治疗。如果病人胃肠道症状较重，不宜选用保和丸、山楂丸、香砂养胃丸等药物。</div><div class="line">4.时行感冒：病人的症状与风热感冒的症状相似。但时行感冒病人较风热感冒病人的症状重。病人可表现为突然畏寒、高热、头痛、怕冷、寒战、头痛剧烈、全身酸痛、疲乏无力、鼻塞、流涕、干咳、胸痛、恶心、食欲不振，婴幼儿或老年人可能并发肺炎或心力衰竭等症状。治疗应以清热解毒、疏风透表为主</div></pre></td></tr></table></figure>
<h4 id="感冒过程"><a href="#感冒过程" class="headerlink" title="感冒过程"></a>感冒过程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.初始症状是头晕，浑身无力，全身酸痛等。</div><div class="line">2.以上症状持续几天之后开始喉咙发炎，头痛加重。。。</div><div class="line">3.由发炎引起其他地方发炎，且一些症状加重，流鼻涕，咳嗽等。</div><div class="line">4.病情严重</div></pre></td></tr></table></figure>
<h4 id="感冒可采取一些的药物"><a href="#感冒可采取一些的药物" class="headerlink" title="感冒可采取一些的药物"></a>感冒可采取一些的药物</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1.发烧、头痛。这时候就需要解热镇痛成分——对乙酰氨基酚、阿司匹林、双氯芬酸</div><div class="line">2.鼻塞，为什么会鼻塞呢？主要是鼻腔充血，我们需要一些减轻鼻腔充血的药物，比如——伪麻黄碱</div></pre></td></tr></table></figure>
<h4 id="感冒一些经验"><a href="#感冒一些经验" class="headerlink" title="感冒一些经验"></a>感冒一些经验</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.感冒时初始症状无法抑制时，感冒会有一个上升期，且感冒不断加重</div><div class="line">2.当感冒到达一个高峰期时，此时一些感冒药能够起到一个很大作用</div><div class="line">3.如果有发烧，切记需要吃退烧药</div><div class="line">4.尽量不要打抗生素，对身体危害太大</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何预防感冒&quot;&gt;&lt;a href=&quot;#如何预防感冒&quot; class=&quot;headerlink&quot; title=&quot;如何预防感冒&quot;&gt;&lt;/a&gt;如何预防感冒&lt;/h3&gt;&lt;h4 id=&quot;感冒的定义&quot;&gt;&lt;a href=&quot;#感冒的定义&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="生活" scheme="https://lzm420241.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="感冒" scheme="https://lzm420241.github.io/tags/%E6%84%9F%E5%86%92/"/>
    
      <category term="预防" scheme="https://lzm420241.github.io/tags/%E9%A2%84%E9%98%B2/"/>
    
  </entry>
  
  <entry>
    <title>javascript提升之道</title>
    <link href="https://lzm420241.github.io/2017/05/22/javascript/javascript-2/"/>
    <id>https://lzm420241.github.io/2017/05/22/javascript/javascript-2/</id>
    <published>2017-05-22T15:09:25.000Z</published>
    <updated>2018-04-23T06:12:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不同等级的前端工程师如何解决问题"><a href="#不同等级的前端工程师如何解决问题" class="headerlink" title="不同等级的前端工程师如何解决问题"></a>不同等级的前端工程师如何解决问题</h3><h4 id="初级前端工程师"><a href="#初级前端工程师" class="headerlink" title="初级前端工程师"></a>初级前端工程师</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1.了解问题，通过google或者baidu查找到答案，然后直接将代码copy到页面中，运行发现问题，直ls接push git</div><div class="line">2.</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;不同等级的前端工程师如何解决问题&quot;&gt;&lt;a href=&quot;#不同等级的前端工程师如何解决问题&quot; class=&quot;headerlink&quot; title=&quot;不同等级的前端工程师如何解决问题&quot;&gt;&lt;/a&gt;不同等级的前端工程师如何解决问题&lt;/h3&gt;&lt;h4 id=&quot;初级前端工程师&quot;&gt;
    
    </summary>
    
      <category term="前端知识点总结" scheme="https://lzm420241.github.io/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="javascript" scheme="https://lzm420241.github.io/tags/javascript/"/>
    
      <category term="架构" scheme="https://lzm420241.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>CSS 常见布局总结</title>
    <link href="https://lzm420241.github.io/2017/05/22/javascript/css-1/"/>
    <id>https://lzm420241.github.io/2017/05/22/javascript/css-1/</id>
    <published>2017-05-22T14:45:25.000Z</published>
    <updated>2018-04-23T06:07:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="三栏式布局"><a href="#三栏式布局" class="headerlink" title="三栏式布局"></a>三栏式布局</h3><h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">核心思想:通过margin-left和margin-right来将left和right两栏移到center这一栏中,然后利用position:static的方式来左右平移实现三栏式布局</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span>#header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span>#center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span>#left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span>#right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span>#footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">  <span class="attribute">min-width</span>: <span class="number">550px</span>;      <span class="comment">/* 2x LC width + RC width */</span></div><div class="line">&#125;</div><div class="line"><span class="selector-id">#container</span> &#123;</div><div class="line">  <span class="attribute">padding-left</span>: <span class="number">200px</span>;   <span class="comment">/* LC width */</span></div><div class="line">  <span class="attribute">padding-right</span>: <span class="number">150px</span>;  <span class="comment">/* RC width */</span></div><div class="line">&#125;</div><div class="line"><span class="selector-id">#container</span> <span class="selector-class">.column</span> &#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">  <span class="attribute">float</span>: left;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#center</span> &#123;</div><div class="line">  <span class="attribute">background-color</span>: <span class="number">#e9e9e9</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#left</span> &#123;</div><div class="line">  <span class="attribute">background-color</span>: red;</div><div class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;          <span class="comment">/* LC width */</span></div><div class="line">  <span class="attribute">right</span>: <span class="number">200px</span>;          <span class="comment">/* LC width */</span></div><div class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#right</span> &#123;</div><div class="line">  <span class="attribute">background-color</span>: blue;</div><div class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;          <span class="comment">/* RC width */</span></div><div class="line">  <span class="attribute">margin-right</span>: -<span class="number">150px</span>;  <span class="comment">/* RC width */</span></div><div class="line">&#125;</div><div class="line"><span class="selector-id">#footer</span> &#123;</div><div class="line">  <span class="attribute">clear</span>: both;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#header</span>, </div><div class="line"><span class="selector-id">#footer</span> &#123;</div><div class="line">  <span class="attribute">background-color</span>: <span class="number">#c9c9c9</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*** IE6 Fix ***/</span></div><div class="line">* <span class="selector-tag">html</span> <span class="selector-id">#left</span> &#123;</div><div class="line">  <span class="attribute">left</span>: <span class="number">150px</span>;           <span class="comment">/* RC width */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">核心思想: 将center的div设置width100%,然后内置div利用margin-left和margin-right撑开空间供sub和extra使用,同时内置div和sub,extra刚好布满三栏</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>header<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main-inner"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span>main<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sub"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>sub<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"extra"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>extra<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line">        <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">        <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="selector-tag">body</span> &#123;</div><div class="line">        <span class="attribute">min-width</span>: <span class="number">700px</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="selector-class">.header</span>,</div><div class="line">    <span class="selector-class">.footer</span> &#123;</div><div class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333</span>;</div><div class="line">        <span class="attribute">background</span>: <span class="number">#aaa</span>;</div><div class="line">        <span class="attribute">text-align</span>: center;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="selector-class">.sub</span>,</div><div class="line">    <span class="selector-class">.main</span>,</div><div class="line">    <span class="selector-class">.extra</span> &#123;</div><div class="line">        <span class="attribute">float</span>: left;</div><div class="line">        <span class="attribute">min-height</span>: <span class="number">130px</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="selector-class">.sub</span> &#123;</div><div class="line">        <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</div><div class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">        <span class="attribute">background</span>: red;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="selector-class">.extra</span> &#123;</div><div class="line">        <span class="attribute">margin-left</span>: -<span class="number">220px</span>;</div><div class="line">        <span class="attribute">width</span>: <span class="number">220px</span>;</div><div class="line">        <span class="attribute">background</span>: blue;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="selector-class">.main</span> &#123;</div><div class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="selector-class">.main-inner</span> &#123;</div><div class="line">        <span class="attribute">margin-left</span>: <span class="number">200px</span>;</div><div class="line">        <span class="attribute">margin-right</span>: <span class="number">220px</span>;</div><div class="line">        <span class="attribute">min-height</span>: <span class="number">130px</span>;</div><div class="line">        <span class="attribute">background</span>: green;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="selector-class">.footer</span> &#123;</div><div class="line">        <span class="attribute">clear</span>: both;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">核心思想: 利用<span class="built_in">float</span>的方式将left和right的div撑上,然后设置center的div margin-left和margin-right来实现三栏布局</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span>#left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span>#right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span>#center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#container</span> &#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#left</span>&#123;</div><div class="line">	<span class="attribute">float</span>: left;</div><div class="line">	<span class="attribute">background-color</span>: green;</div><div class="line">	<span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.column</span>&#123;</div><div class="line">	<span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#right</span>&#123;</div><div class="line">	<span class="attribute">float</span>: right;</div><div class="line">	<span class="attribute">background-color</span>: red;</div><div class="line">	<span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#center</span>&#123;</div><div class="line">	<span class="attribute">background-color</span>: yellow;</div><div class="line">	<span class="attribute">margin</span>: auto <span class="number">200px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><h4 id="已知高度宽度元素的水平垂直居中"><a href="#已知高度宽度元素的水平垂直居中" class="headerlink" title="已知高度宽度元素的水平垂直居中"></a>已知高度宽度元素的水平垂直居中</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">核心思想(一): 绝对定位与负边距实现</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#container</span>&#123;</div><div class="line">    <span class="attribute">position</span>:relative;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-id">#center</span>&#123;</div><div class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</div><div class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</div><div class="line">    <span class="attribute">position</span>:absolute;</div><div class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</div><div class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</div><div class="line">    <span class="attribute">margin</span>:-<span class="number">50px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">50px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">核心思想(二): 绝对定位与margin</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#container</span>&#123;</div><div class="line">    <span class="attribute">position</span>:relative;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-id">#center</span>&#123;</div><div class="line">    <span class="attribute">position</span>:absolute;</div><div class="line">    <span class="attribute">margin</span>:auto;</div><div class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">bottom</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">right</span>:<span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="未知高度和宽度元素的水平垂直居中"><a href="#未知高度和宽度元素的水平垂直居中" class="headerlink" title="未知高度和宽度元素的水平垂直居中"></a>未知高度和宽度元素的水平垂直居中</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">核心思想(一): 当要被居中的元素是inline或者inline-block元素可以巧妙的将父级容器设置为display:table-cell，配合text-align:center和vertical-align:middle即可以实现水平垂直居中</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#container</span>&#123;</div><div class="line">    <span class="attribute">display</span>:table-cell;</div><div class="line">    <span class="attribute">text-align</span>:center;</div><div class="line">    <span class="attribute">vertical-align</span>:middle;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-id">#center</span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">核心思想(二): 利用Css3的transform，可以轻松的在未知元素的高宽的情况下实现元素的垂直居中</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#container</span>&#123;</div><div class="line">    <span class="attribute">position</span>:relative;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-id">#center</span>&#123;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">核心思想(三): 使用flex布局，无需绝对定位等改变布局的操作，可以轻松实现元素的水平垂直居中</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#container</span>&#123;</div><div class="line">    <span class="attribute">display</span>:flex;</div><div class="line">    <span class="attribute">justify-content</span>:center;</div><div class="line">    <span class="attribute">align-items</span>: center;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-id">#center</span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;三栏式布局&quot;&gt;&lt;a href=&quot;#三栏式布局&quot; class=&quot;headerlink&quot; title=&quot;三栏式布局&quot;&gt;&lt;/a&gt;三栏式布局&lt;/h3&gt;&lt;h4 id=&quot;圣杯布局&quot;&gt;&lt;a href=&quot;#圣杯布局&quot; class=&quot;headerlink&quot; title=&quot;圣杯布局&quot;
    
    </summary>
    
      <category term="前端知识点总结" scheme="https://lzm420241.github.io/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="css" scheme="https://lzm420241.github.io/tags/css/"/>
    
      <category term="css layout" scheme="https://lzm420241.github.io/tags/css-layout/"/>
    
  </entry>
  
  <entry>
    <title>MVVM模式及与MVP和MVC的区别</title>
    <link href="https://lzm420241.github.io/2017/05/22/javascript/javascript-1/"/>
    <id>https://lzm420241.github.io/2017/05/22/javascript/javascript-1/</id>
    <published>2017-05-22T14:43:58.000Z</published>
    <updated>2018-04-23T06:02:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="三种模式的思想"><a href="#三种模式的思想" class="headerlink" title="三种模式的思想"></a>三种模式的思想</h3><h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><ol>
<li>View 传送指令到 Controller</li>
<li>Controller 完成业务逻辑后，要求 Model 改变状态</li>
<li>Model 将新的数据发送到 View，用户得到反馈</li>
</ol>
<h4 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h4><ol>
<li>各部分之间的通信，都是双向的。</li>
<li>View 与 Model 不发生联系，都通过 Presenter 传递。</li>
<li>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</li>
</ol>
<h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><ol>
<li>将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致</li>
<li>唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel</li>
</ol>
<h4 id="三者之间的逻辑图"><a href="#三者之间的逻辑图" class="headerlink" title="三者之间的逻辑图"></a>三者之间的逻辑图</h4><p><img src="http://okzxxeq9y.bkt.clouddn.com/mvc_mvp_mvvm.jpg" alt="Alt text"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;三种模式的思想&quot;&gt;&lt;a href=&quot;#三种模式的思想&quot; class=&quot;headerlink&quot; title=&quot;三种模式的思想&quot;&gt;&lt;/a&gt;三种模式的思想&lt;/h3&gt;&lt;h4 id=&quot;MVC&quot;&gt;&lt;a href=&quot;#MVC&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="前端知识点总结" scheme="https://lzm420241.github.io/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="javascript" scheme="https://lzm420241.github.io/tags/javascript/"/>
    
      <category term="架构" scheme="https://lzm420241.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>堆栈存储区别及常用算法总结</title>
    <link href="https://lzm420241.github.io/2017/05/22/algorithm/algorithm-1/"/>
    <id>https://lzm420241.github.io/2017/05/22/algorithm/algorithm-1/</id>
    <published>2017-05-22T14:40:47.000Z</published>
    <updated>2018-04-23T06:03:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="堆栈之间的区别"><a href="#堆栈之间的区别" class="headerlink" title="堆栈之间的区别"></a>堆栈之间的区别</h3><ol>
<li>栈区（stack）由编译器自动分配释放，存放函数的参数值，局部变量的值等 其操作方式类似于数据结构中的栈</li>
<li>堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收 注意它与数据结构中的堆是两回事，分配方式倒是类似于链表</li>
<li>申请后系统的响应: 只要栈的剩余空间大于所申·请空间，系统将为程序提供内存，否则将报异常提示栈溢出;首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时,会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中</li>
<li>申请大小的限制 : 栈获得的空间较小,堆获得的空间比较灵活，也比较大</li>
<li>申请效率的比较: 栈由系统自动分配，速度较快,但程序员是无法控制的;堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便;</li>
<li>堆和栈中的存储内容 : 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数;一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排;</li>
<li>存取效率的比较: 在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快</li>
</ol>
<h3 id="DP算法-Dynamic-programming"><a href="#DP算法-Dynamic-programming" class="headerlink" title="DP算法(Dynamic programming)"></a>DP算法(Dynamic programming)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.动态规划的本质，是对问题状态的定义和状态转移方程的定义</div><div class="line">2.将问题发展到各个阶段时所处于的各种客观情况用不同的状态,而且状态的选择要满足无后效性,即对后面的状态无任何影响</div><div class="line">3.上述状态定义好之后，状态和状态之间的关系式，就叫做状态转移方程</div><div class="line">4.典型例子: 01背包问题,装配线调度</div></pre></td></tr></table></figure>
<h3 id="DFS算法-Depth-First-Search"><a href="#DFS算法-Depth-First-Search" class="headerlink" title="DFS算法(Depth-First-Search)"></a>DFS算法(Depth-First-Search)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">深度优先搜索在搜索过程中访问某个顶点后，需要递归地访问此顶点的所有未访问过的相邻顶点。</div><div class="line">初始条件下所有节点为白色，选择一个作为起始顶点，按照如下步骤遍历：</div><div class="line">a. 选择起始顶点涂成灰色，表示还未访问</div><div class="line">b. 从该顶点的邻接顶点中选择一个，继续这个过程（即再寻找邻接结点的邻接结点），一直深入下去，直到一个顶点没有邻接结点了，涂黑它，表示访问过了</div><div class="line">c. 回溯到这个涂黑顶点的上一层顶点，再找这个上一层顶点的其余邻接结点，继续如上操作，如果所有邻接结点往下都访问过了，就把自己涂黑，再回溯到更上一层。</div><div class="line">d. 上一层继续做如上操作，知道所有顶点都访问过。</div><div class="line"></div><div class="line">核心是通过栈的方式实现</div></pre></td></tr></table></figure>
<h3 id="BFS算法-Breadth-First-Search"><a href="#BFS算法-Breadth-First-Search" class="headerlink" title="BFS算法(Breadth-First-Search)"></a>BFS算法(Breadth-First-Search)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">广度优先搜索在进一步遍历图中顶点之前，先访问当前顶点的所有邻接结点。</div><div class="line">a .首先选择一个顶点作为起始结点，并将其染成灰色，其余结点为白色。</div><div class="line">b. 将起始结点放入队列中。</div><div class="line">c. 从队列首部选出一个顶点，并找出所有与之邻接的结点，将找到的邻接结点放入队列尾部，将已访问过结点涂成黑色，没访问过的结点是白色。如果顶点的颜色是灰色，表示已经发现并且放入了队列，如果顶点的颜色是白色，表示还没有发现</div><div class="line">d. 按照同样的方法处理队列中的下一个结点。</div><div class="line">基本就是出队的顶点变成黑色，在队列里的是灰色，还没入队的是白色</div><div class="line"></div><div class="line">核心是通过队列的方式实现</div></pre></td></tr></table></figure>
<h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">核心思想: 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</div></pre></td></tr></table></figure>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">核心思想: 在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）</div></pre></td></tr></table></figure>
<h3 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">核心思想: 所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索</div></pre></td></tr></table></figure>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">核心思想: 在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;堆栈之间的区别&quot;&gt;&lt;a href=&quot;#堆栈之间的区别&quot; class=&quot;headerlink&quot; title=&quot;堆栈之间的区别&quot;&gt;&lt;/a&gt;堆栈之间的区别&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;栈区（stack）由编译器自动分配释放，存放函数的参数值，局部变量的值等 其操作方式类似
    
    </summary>
    
      <category term="算法" scheme="https://lzm420241.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="stack heap" scheme="https://lzm420241.github.io/tags/stack-heap/"/>
    
      <category term="DP DFS BFS" scheme="https://lzm420241.github.io/tags/DP-DFS-BFS/"/>
    
  </entry>
  
  <entry>
    <title>前端常见面试题归纳(三)</title>
    <link href="https://lzm420241.github.io/2017/05/21/interview/interview-3/"/>
    <id>https://lzm420241.github.io/2017/05/21/interview/interview-3/</id>
    <published>2017-05-21T05:35:59.000Z</published>
    <updated>2018-04-23T06:03:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">行框的排列会受到代码中间空白（回车\空格）等的影响,当li通过换行后会产生空白</div><div class="line">解决方案：</div><div class="line">1.浮动li中<span class="built_in">float</span>：left</div><div class="line">2.在ul中用font-size：0（谷歌不支持）；可以使用letter-space：-3px</div><div class="line">3.li之间不换行，且不留空格</div></pre></td></tr></table></figure>
<h3 id="如果需要手动写动画，你认为最小时间间隔是多久，为什么？"><a href="#如果需要手动写动画，你认为最小时间间隔是多久，为什么？" class="headerlink" title="如果需要手动写动画，你认为最小时间间隔是多久，为什么？"></a>如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms</div></pre></td></tr></table></figure>
<h3 id="什么叫做优雅降级和渐进增强"><a href="#什么叫做优雅降级和渐进增强" class="headerlink" title="什么叫做优雅降级和渐进增强"></a>什么叫做优雅降级和渐进增强</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</div><div class="line">优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览</div></pre></td></tr></table></figure>
<h3 id="如何解决跨域"><a href="#如何解决跨域" class="headerlink" title="如何解决跨域"></a>如何解决跨域</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">跨域资源共享</div><div class="line">    基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败</div><div class="line">jsonp跨域</div><div class="line">    JSONP也叫填充式JSON，是应用JSON的一种新方法，只不过是被包含在函数调用中的JSON</div><div class="line">通过修改document.domain来跨子域</div><div class="line">使用HTML5的window.postMessage方法跨域</div></pre></td></tr></table></figure>
<h3 id="关于javascript中apply-和call-方法的区别"><a href="#关于javascript中apply-和call-方法的区别" class="headerlink" title="关于javascript中apply()和call()方法的区别"></a>关于javascript中apply()和call()方法的区别</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">方法传递的参数不同 apply是数组传递，call是单个值传递</div></pre></td></tr></table></figure>
<h3 id="XSS和CSRF原理"><a href="#XSS和CSRF原理" class="headerlink" title="XSS和CSRF原理"></a>XSS和CSRF原理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">XSS 全称(Cross Site Scripting) 跨站脚本攻击，是Web程序中最常见的漏洞。指攻击者在网页中嵌入客户端脚本(例如JavaScript),当用户浏览此网页时，脚本就会在用户的浏览器上执行，从而达到攻击者的目的.  比如获取用户的Cookie，导航到恶意网站,携带木马等</div><div class="line">CSRF攻击(Cross Site Request Forgery) 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法</div></pre></td></tr></table></figure>
<h3 id="多个标签页之间的通信"><a href="#多个标签页之间的通信" class="headerlink" title="多个标签页之间的通信"></a>多个标签页之间的通信</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">通过localstorage实现 当localstorage里面发生改变就会出发storage事件</div><div class="line">通过WebSocket实现</div></pre></td></tr></table></figure>
<h3 id="什么是FOUC？如何避免FOUC-Flash-of-Unstyled-Content-？"><a href="#什么是FOUC？如何避免FOUC-Flash-of-Unstyled-Content-？" class="headerlink" title="什么是FOUC？如何避免FOUC(Flash of Unstyled Content)？"></a>什么是FOUC？如何避免FOUC(Flash of Unstyled Content)？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">FOUC即文档样式短暂失效，也就是HTML代码加载成功时它的CSS文件还没有加载，导致出现的网页内容没有样式，一般有这几种情况会导致FOUC：</div><div class="line">    1、使用import方法导入样式表</div><div class="line">    2、HTML代码在前，CSS样式表在后</div><div class="line">解决方法也很简单:</div><div class="line">    1、尽量减少使用import方法导入样式表</div><div class="line">    2、CSS样式表全部放到HEAD里</div></pre></td></tr></table></figure>
<h3 id="null和undefined的区别"><a href="#null和undefined的区别" class="headerlink" title="null和undefined的区别"></a>null和undefined的区别</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">null表示<span class="string">"没有对象"</span>，即该处不应该有值</div><div class="line">undefined表示<span class="string">"缺少值"</span>，就是此处应该有一个值，但是还没有定义</div></pre></td></tr></table></figure>
<h3 id="AMD规范与CMD规范的区别"><a href="#AMD规范与CMD规范的区别" class="headerlink" title="AMD规范与CMD规范的区别"></a>AMD规范与CMD规范的区别</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.对于依赖的模块，AMD 是提前执行，CMD 是延迟执行</div><div class="line">2.CMD 推崇依赖就近，AMD 推崇依赖前置</div><div class="line">3.AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一</div></pre></td></tr></table></figure>
<h3 id="JavaScript-对象的深度克隆"><a href="#JavaScript-对象的深度克隆" class="headerlink" title="JavaScript 对象的深度克隆"></a>JavaScript 对象的深度克隆</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">浅度克隆 ：基本类型为值传递，对象仍为引用传递</div><div class="line">深度克隆 ：所有元素或属性均完全克隆，并于原引用类型完全独立，即，在后面修改对象的属性的时候，原对象不会被修改</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 判断arr是否为一个数组，返回一个bool值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arr) === <span class="string">'[object Array]'</span>;  </div><div class="line">&#125;</div><div class="line"><span class="comment">// 深度克隆</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span> (<span class="params">obj</span>) </span>&#123;  </div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> obj !== <span class="string">'function'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> obj;        <span class="comment">//原始类型直接返回</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> o = isArray(obj) ? [] : &#123;&#125;; </div><div class="line">    <span class="keyword">for</span>(i <span class="keyword">in</span> obj) &#123;  </div><div class="line">        <span class="keyword">if</span>(obj.hasOwnProperty(i))&#123; </div><div class="line">            o[i] = <span class="keyword">typeof</span> obj[i] === <span class="string">"object"</span> ? deepClone(obj[i]) : obj[i]; </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？&quot;&gt;&lt;a href=&quot;#li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？&quot; class=&quot;headerlink&quot; title=&quot;li与li之间有看不见的空白间隔是什么原因引起的？有
    
    </summary>
    
      <category term="前端知识点总结" scheme="https://lzm420241.github.io/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="前端面试题" scheme="https://lzm420241.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>前端常见面试题归纳(二)</title>
    <link href="https://lzm420241.github.io/2017/05/21/interview/interview-2/"/>
    <id>https://lzm420241.github.io/2017/05/21/interview/interview-2/</id>
    <published>2017-05-21T03:30:27.000Z</published>
    <updated>2018-04-23T06:03:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Q-从-URL-输入到页面展现发生了什么"><a href="#Q-从-URL-输入到页面展现发生了什么" class="headerlink" title="Q:从 URL 输入到页面展现发生了什么"></a>Q:从 URL 输入到页面展现发生了什么</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">1.将URL输入到浏览器中</div><div class="line">2.浏览器根据域名查找IP地址</div><div class="line">    DNS查找过程如下：</div><div class="line">        Browser cache(浏览器缓存)—浏览器会缓存DNS记录一段时间。有趣的是，操作系统并没有告诉浏览器每一个DNS记录缓存的存活时间，所以浏览器自己会缓存它们固定的一段时间（不同的浏览器存在差异，一般是2-30分钟）。</div><div class="line">        OS cache（操作系统缓存）—如果浏览器缓存中没有找到对应的记录，浏览器就会做一次系统请求（Windows系统中就是根据名称从host文件中获得IP地址）。操作系统有它自己的缓存。</div><div class="line">        Router cache（路由缓存）—请求会在你的路由器上继续进行，路由一般都会有自己的DNS缓存。</div><div class="line">        ISP DNS cache(ISP DNS缓存)—下一个地方就是查找ISP<span class="string">'s DNS服务器了，当然，它也会有一份缓存。</span></div><div class="line">        Recursive search(递归查找)—你的ISP's DNS服务从根域名开始循环查找，根据.com查找顶级域名服务器，然后再到 Facebook 的域名服务器。通常来说，DNS服务器都会有.com域名服务器的缓存，所以根域名服务器不是必须的</div><div class="line">3.浏览器发送一个HTTP请求到浏览器</div><div class="line">4.服务器通过重定向进行响应</div><div class="line">5.浏览器重定向</div><div class="line">6.服务器处理请求</div><div class="line">7.服务器返回HTML响应</div><div class="line">8.浏览器开始渲染HTML</div><div class="line">9.浏览器为嵌入的对象发送请求 （例如：图片等）</div><div class="line">10.浏览器发送AJAX请求</div></pre></td></tr></table></figure>
<h3 id="Q-JS-引用类型笔试题"><a href="#Q-JS-引用类型笔试题" class="headerlink" title="Q:JS 引用类型笔试题"></a>Q:JS 引用类型笔试题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//红宝书 ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">x, y</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> temp = x;</div><div class="line">  x = y;</div><div class="line">  y = temp;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span></div><div class="line"><span class="keyword">var</span> b = <span class="number">2</span></div><div class="line">swap(a, b)</div><div class="line"><span class="built_in">console</span>.log(a) <span class="comment">//输出什么</span></div><div class="line"><span class="built_in">console</span>.log(b) <span class="comment">//输出什么</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">name</span>: <span class="string">'jirengu'</span>&#125;</div><div class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">age</span>: <span class="number">2</span>&#125;</div><div class="line">swap(obj1, obj2)</div><div class="line"><span class="built_in">console</span>.log(obj1)  <span class="comment">//输出什么</span></div><div class="line"><span class="built_in">console</span>.log(obj2)  <span class="comment">//输出什么</span></div><div class="line"></div><div class="line">A:</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line">&#123;<span class="attr">name</span>: <span class="string">'jirengu'</span>&#125;</div><div class="line">&#123;<span class="attr">age</span>: <span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<h3 id="Q-JS-字符串操作面试题"><a href="#Q-JS-字符串操作面试题" class="headerlink" title="Q:JS 字符串操作面试题"></a>Q:JS 字符串操作面试题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 请用JavaScript 实现一个方法，该方法能够判断两个字符串是否匹配</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isMatch</span>(<span class="params">str1, str2</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line">isMatch(<span class="string">'something'</span>, <span class="string">'ginhtemos'</span>)  <span class="comment">// true</span></div><div class="line">isMatch(<span class="string">'aaa'</span>, <span class="string">'aa'</span>)  <span class="comment">//false</span></div><div class="line">isMatch(<span class="string">'abb'</span>, <span class="string">'baa'</span>)  <span class="comment">//false</span></div><div class="line">isMatch(<span class="string">'hello'</span>, <span class="string">'olelh'</span>)  <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//A:</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isMatch</span>(<span class="params">str1, str2</span>)</span>&#123;</div><div class="line">   <span class="keyword">return</span> str1.split(<span class="string">''</span>).sort().join(<span class="string">''</span>) === str2.split(<span class="string">''</span>).sort().join(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Q-JS-运算符优先级相关题目"><a href="#Q-JS-运算符优先级相关题目" class="headerlink" title="Q:JS 运算符优先级相关题目"></a>Q:JS 运算符优先级相关题目</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Q:</span></div><div class="line"><span class="comment">// object1和object2 都是对象，所以运算的时候会调用valueOf方法</span></div><div class="line">(<span class="number">2</span> &gt; <span class="number">1</span> + -<span class="number">-1</span>) + <span class="literal">true</span>)</div><div class="line"><span class="comment">// 布尔值在运算时会自动转为数字 true -&gt; 1 false -&gt; 0</span></div><div class="line">(<span class="number">1</span>+ <span class="number">0</span>) + <span class="number">1</span>)</div></pre></td></tr></table></figure>
<h3 id="Q-JS-类型判断相关问题"><a href="#Q-JS-类型判断相关问题" class="headerlink" title="Q:JS 类型判断相关问题"></a>Q:JS 类型判断相关问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.写一个函数 isEmptyObject，判断一个对象是不是空对象</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmptyObject</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">  <span class="comment">// todo...</span></div><div class="line">&#125;</div><div class="line">isEmptyObject( &#123;&#125; ); <span class="comment">//true</span></div><div class="line">isEmptyObject( &#123;<span class="attr">a</span>:<span class="number">1</span>&#125; ) ; <span class="comment">//false</span></div><div class="line"><span class="comment">// 2.如果可以用 ES5，那么你会如何写这个函数？</span></div><div class="line"></div><div class="line"><span class="comment">// Q:</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmptyObject</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>( <span class="built_in">arguments</span>[<span class="number">0</span>] &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">0</span>] === <span class="string">"object"</span> ) &#123;</div><div class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> key <span class="keyword">in</span> <span class="built_in">arguments</span>[<span class="number">0</span>] ) &#123;</div><div class="line">    　<span class="keyword">return</span> <span class="literal">true</span></div><div class="line">  　&#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">throw</span> <span class="string">"obj need to be an object"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// es6</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmptyObject</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="built_in">Object</span>.keys(obj).length === <span class="number">0</span> &amp;&amp; obj.constructor === <span class="built_in">Object</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 循环/闭包/setTimeout/Promise 综合</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0..4</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;, <span class="number">1000</span> * i);</div><div class="line">&#125;</div><div class="line"><span class="comment">//5..5</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;, i * <span class="number">1000</span>);</div><div class="line">  &#125;)(i);</div><div class="line">&#125;</div><div class="line"><span class="comment">//0..4</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;, i * <span class="number">1000</span>);</div><div class="line">  &#125;)(i);</div><div class="line">&#125;</div><div class="line"><span class="comment">//5..5</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">  setTimeout((<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;)(i), i * <span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//5..5  **0..4**</span></div><div class="line"><span class="comment">// setTimeout(undefined, i*1000);</span></div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;<span class="number">10000</span> ; i++ ) &#123;</div><div class="line">    i == <span class="number">9999</span> &amp;&amp; resolve();</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</div><div class="line"><span class="comment">//2 3 5 4 1</span></div></pre></td></tr></table></figure>
<h3 id="什么闭包-闭包有什么用"><a href="#什么闭包-闭包有什么用" class="headerlink" title="什么闭包,闭包有什么用"></a>什么闭包,闭包有什么用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量</div><div class="line">闭包作用域链通常包括三个部分：</div><div class="line">    函数本身作用域</div><div class="line">    闭包定义时的作用域</div><div class="line">    全局作用域</div><div class="line">闭包常见用途：</div><div class="line">    创建特权方法用于访问控制</div><div class="line">    事件处理程序及回调</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Q-从-URL-输入到页面展现发生了什么&quot;&gt;&lt;a href=&quot;#Q-从-URL-输入到页面展现发生了什么&quot; class=&quot;headerlink&quot; title=&quot;Q:从 URL 输入到页面展现发生了什么&quot;&gt;&lt;/a&gt;Q:从 URL 输入到页面展现发生了什么&lt;/h3&gt;&lt;
    
    </summary>
    
      <category term="前端知识点总结" scheme="https://lzm420241.github.io/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="前端面试题" scheme="https://lzm420241.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>前端常见面试题归纳(一)</title>
    <link href="https://lzm420241.github.io/2017/05/21/interview/interview/"/>
    <id>https://lzm420241.github.io/2017/05/21/interview/interview/</id>
    <published>2017-05-21T01:54:17.000Z</published>
    <updated>2018-04-23T06:03:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>1.<strong>DOM操作</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">createElement 通过传入指定的一个标签名来创建一个元素，如果传入的标签名是一个未知的，则会创建一个自定义的标签</div><div class="line">createTextNode createTextNode用来创建一个文本节点</div><div class="line"><span class="built_in">clone</span>Node <span class="built_in">clone</span>Node是用来返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否复制子元素</div><div class="line">createDocumentFragment createDocumentFragment方法用来创建一个DocumentFragment</div><div class="line">appendChild 将指定的节点添加到调用该方法的节点的子元素的末尾</div><div class="line">insertBefore insertBefore用来添加一个节点到一个参照节点之前</div><div class="line">removeChild 删除指定的子节点并返回</div><div class="line">replaceChild replaceChild用于使用一个节点替换另一个节点</div><div class="line">document.getElementById 根据元素id返回元素，返回值是Element类型，如果不存在该元素，则返回null</div><div class="line">document.getElementsByTagName 这个接口根据元素标签名获取元素，返回一个即时的HTMLCollection类型</div><div class="line">document.getElementsByName getElementsByName主要是通过指定的name属性来获取元素，它返回一个即时的NodeList对象</div><div class="line">document.getElementsByClassName 这个API是根据元素的class返回一个即时的HTMLCollection</div><div class="line">document.querySelector和document.querySelectorAll 通过css选择器来查找元素</div><div class="line">节点关系型api parentNode parentElement previousSibling previousElementSibling nextSibling nextElementSibling childNodes children firstNode lastNode hasChildNodes</div><div class="line">元素属性型api <span class="built_in">set</span>Attribute getAttribute</div><div class="line">元素样式型api </div><div class="line">window.getComputedStyle 用来获取应用到元素后的样式</div><div class="line">getBoundingClientRect 用来返回元素的大小以及相对于浏览器可视窗口的位置</div></pre></td></tr></table></figure></p>
<p>2.<strong>如何使用事件</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HTML内连属性</div><div class="line">DOM属性绑定</div><div class="line">事件监听函数 addEventListener</div><div class="line">移除事件监听 removeEventListener</div><div class="line">模拟触发事件 dispatchEvent</div><div class="line">自定义事件 Event、CustomEvent 和 dispatchEvent</div><div class="line">事件顺序 捕获阶段-&gt;达到元素后-&gt;进入事件冒泡阶段</div><div class="line">事件Event对象几个属性：<span class="built_in">type</span>(string)，target(node)，currentTarget(node)，bubbles(boolean),preventDefault (<span class="keyword">function</span>),stopPropagation (<span class="keyword">function</span>),stopImmediatePropagation (<span class="keyword">function</span>),cancelable (boolean),eventPhase (number)</div></pre></td></tr></table></figure></p>
<p>3.<strong>XMLHttpRequest详解</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//XMLHttpRequest发送的ajax请求代码：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendAjax</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//构造表单数据</span></div><div class="line">  <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</div><div class="line">  formData.append(<span class="string">'username'</span>, <span class="string">'johndoe'</span>);</div><div class="line">  formData.append(<span class="string">'id'</span>, <span class="number">123456</span>);</div><div class="line">  <span class="comment">//创建xhr对象 </span></div><div class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">  <span class="comment">//设置xhr请求的超时时间</span></div><div class="line">  xhr.timeout = <span class="number">3000</span>;</div><div class="line">  <span class="comment">//设置响应返回的数据格式</span></div><div class="line">  xhr.responseType = <span class="string">"text"</span>;</div><div class="line">  <span class="comment">//创建一个 post 请求，采用异步</span></div><div class="line">  xhr.open(<span class="string">'POST'</span>, <span class="string">'/server'</span>, <span class="literal">true</span>);</div><div class="line">  <span class="comment">//注册相关事件回调处理函数</span></div><div class="line">  xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; </div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status == <span class="number">200</span>||<span class="keyword">this</span>.status == <span class="number">304</span>)&#123;</div><div class="line">        alert(<span class="keyword">this</span>.responseText);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; ... &#125;;</div><div class="line">  xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; ... &#125;;</div><div class="line">  xhr.upload.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; ... &#125;;</div><div class="line">  </div><div class="line">  <span class="comment">//发送数据</span></div><div class="line">  xhr.send(formData);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">XHR 对象的属性和方法</div><div class="line">属性:</div><div class="line">    readyState：HTTP 请求的状态</div><div class="line">    responseText：响应体（不包括头部）</div><div class="line">    responseXML：对请求的响应，解析为 XML 并作为 Document 对象返回</div><div class="line">    status：由服务器返回的 HTTP 状态代码，如 200 表示成功</div><div class="line">    statusText：这个属性用名称而不是数字指定了请求的 HTTP 的状态代码。也就是说，当状态为 200 的时候它是 <span class="string">"OK"</span>，当状态为 404 的时候它是 <span class="string">"Not Found"</span></div><div class="line">    responseType：返回的我们设置的数据类型（text，document，json，blob，arrayBuffer）</div><div class="line">    timeout：设置请求的超时时间</div><div class="line">方法:</div><div class="line">    loadstart(): 调用xhr.send()方法后立即触发</div><div class="line">    progress(): xhr.upload.onprogress在上传阶段(即xhr.send()之后，xhr.readystate=2之前)触发，每50ms触发一次；xhr.onprogress在下载阶段（即xhr.readystate=3时）触发，每50ms触发一次</div><div class="line">    timeout: xhr.timeout不等于0，由请求开始即onloadstart开始算起，当到达xhr.timeout所设置时间请求还未结束即onloadend，则触发此事件</div><div class="line">    load: 当请求成功完成时触发，此时xhr.readystate=4</div><div class="line">    loadend: 当请求结束（包括请求成功和请求失败）时触发</div><div class="line">    abort() : 取消当前响应，关闭连接并且结束任何未决的网络活动</div><div class="line">    getAllResponseHeaders()：把 HTTP 响应头部作为未解析的字符串返回</div><div class="line">    getResponseHeader()：返回指定的 HTTP 响应头部的值</div><div class="line">    open(method,url[,async = <span class="literal">true</span>[,username = null, [,password = null]])：初始化 HTTP 请求参数，例如 URL 和 HTTP 方法，但是并不发送请求</div><div class="line">    send()：发送 HTTP 请求，使用传递给 open() 方法的参数，以及传递给该方法的可选请求体</div><div class="line">    <span class="built_in">set</span>RequestHeader()：向一个打开但未发送的请求设置或添加一个 HTTP 请求</div><div class="line">    overrideMimeType()：返回的我们设置的数据类型</div><div class="line"></div><div class="line">xhr事件：onreadystatechange 监听xhr返回时的事件</div><div class="line">获取上传、下载的进度: onprogress事件</div><div class="line">    上传触发的是xhr.upload对象的 onprogress事件</div><div class="line">    下载触发的是xhr对象的onprogress事件</div><div class="line">事件出发顺序：</div><div class="line">    1.触发xhr.onreadystatechange(之后每次readyState变化时，都会触发一次)</div><div class="line">    2.触发xhr.onloadstart</div><div class="line">    //上传阶段开始：</div><div class="line">    3.触发xhr.upload.onloadstart</div><div class="line">    4.触发xhr.upload.onprogress</div><div class="line">    5.触发xhr.upload.onload</div><div class="line">    6.触发xhr.upload.onloadend</div><div class="line">    //上传结束，下载阶段开始：</div><div class="line">    7.触发xhr.onprogress</div><div class="line">    8.触发xhr.onload</div><div class="line">    9.触发xhr.onloadend</div></pre></td></tr></table></figure>
<p>4.<strong>如何使用浮动元素，以及带来的问题和解决方案</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">浮动定义：浮动的框可以左右移动，直至它的外边缘遇到包含框或者另一个浮动框的边缘，通过设置<span class="built_in">float</span>属性实现</div><div class="line">现象：正是因为浮动的这种特性，导致本属于普通流中的元素浮动之后，包含框内部由于不存在其他普通流元素了，也就表现出高度为0（高度塌陷）。在实际布局中，往往这并不是我们所希望的，所以需要闭合浮动元素，使其包含框表现出正常的高度</div><div class="line">如何清除浮动：</div><div class="line">    清除浮动：清除对应的单词是 clear，对应CSS中的属性是 clear：left | right | both | none</div><div class="line">    闭合浮动：更确切的含义是使浮动元素闭合，从而减少浮动带来的影响</div><div class="line">BFC的特性</div><div class="line">    块级格式化上下文会阻止外边距叠加</div><div class="line">    当两个相邻的块框在同一个块级格式化上下文中时，它们之间垂直方向的外边距会发生叠加。换句话说，如果这两个相邻的块框不属于同一个块级格式化上下文，那么它们的外边距就不会叠加。</div><div class="line">    块级格式化上下文不会重叠浮动元素</div><div class="line">    根据规定，一个块级格式化上下文的边框不能和它里面的元素的外边距重叠。这就意味着浏览器将会给块级格式化上下文创建隐式的外边距来阻止它和浮动元素的外边距叠加。由于这个原因，当给一个挨着浮动的块级格式化上下文添加负的外边距时将会不起作用（Webkit和IE6在这点上有一个问题——可以看这个测试用例）。</div><div class="line">    块级格式化上下文通常可以包含浮动</div><div class="line">如何触发BFC?</div><div class="line">    <span class="built_in">float</span> 除了none以外的值</div><div class="line">    overflow 除了visible 以外的值（hidden，auto，scroll ）</div><div class="line">    display (table-cell，table-caption，inline-block)</div><div class="line">    position（absolute，fixed）</div><div class="line">    fieldset元素</div><div class="line">BFC的几个用途</div><div class="line">    1、BFC可以阻止垂直边距叠加问题</div><div class="line">    2、BFC可以包含内部元素的浮动</div><div class="line">    3、BFC可以阻止元素被浮动覆盖</div><div class="line">    4、BFC可以决定清除浮动的范围</div></pre></td></tr></table></figure></p>
<p>5.<strong>HTMLXHTML区别，如何选择</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">xhtml:</div><div class="line">    1.所有的标记都都要闭合 </div><div class="line">    2.所有标签的元素和属性的名字都必须使用小写 </div><div class="line">    3.所有的XML标记都必须合理嵌套 </div><div class="line">    4.所有的属性必须用引号（单或双）包括在HTML中，你可以不需要给属性值加引号，但是在XHTML中，它们必须被加引号</div><div class="line">    5.把所有&lt;和&amp;特殊符号用编码表示任何小于号（&lt;），不是标签的一部分，都必须被编码为&amp; l t ; 任何大于号（&gt;），不是标签的一部分，都必须被编码为&amp; g t ; 任何与号（&amp;），不是实体的一部分的，都必须被编码为&amp; a m p</div><div class="line">    6.给所有属性赋一个值 </div><div class="line">    7.不要在注释内容中使<span class="string">"- -"</span> </div><div class="line">    8.图片必须有说明文字 每个图片标签都必须有ALT说明文字</div></pre></td></tr></table></figure></p>
<p>6.<strong>JSON作用，用途，设计结构</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">JSON API 是数据交互规范，用以定义客户端如何获取与修改资源，以及服务器如何响应对应请求</div><div class="line">JSON API设计用来最小化请求的数量，以及客户端与服务器间传输的数据量。在高效实现的同时，无需牺牲可读性、灵活性和可发现性</div><div class="line">JSON API需要使用JSON API媒体类型(application/vnd.api+json) 进行数据交互</div><div class="line">JSON API服务器支持通过GET方法获取资源。而且必须独立实现HTTP POST, PUT和DELETE方法的请求响应，以支持资源的创建、更新和删除</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h3&gt;&lt;p&gt;1.&lt;strong&gt;DOM操作&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;ta
    
    </summary>
    
      <category term="前端知识点总结" scheme="https://lzm420241.github.io/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="前端面试题" scheme="https://lzm420241.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>5.图层的高级操作</title>
    <link href="https://lzm420241.github.io/2017/05/20/design/ps-5/"/>
    <id>https://lzm420241.github.io/2017/05/20/design/ps-5/</id>
    <published>2017-05-20T14:53:47.000Z</published>
    <updated>2018-04-23T06:04:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图层的设置"><a href="#图层的设置" class="headerlink" title="图层的设置"></a>图层的设置</h3><ol>
<li>图层控制面板中可以设置不透明度</li>
<li>混合模式用来控制当前图层中的像素与它下面图层中的像素如何混合，除背景图层外，其他图层都支持混合，另外用于混合通道</li>
</ol>
<h3 id="填充图层"><a href="#填充图层" class="headerlink" title="填充图层"></a>填充图层</h3><ol>
<li>图层➡新建填充图层➡纯色 或单机图层面板中创建新的填充或调整图层按钮，选择纯色</li>
<li>渐变填充图层 图层➡新建填充图层➡渐变或者创建新的填充或调整图层按钮，选择渐变</li>
</ol>
<h3 id="调整图层"><a href="#调整图层" class="headerlink" title="调整图层"></a>调整图层</h3><ol>
<li>图层➡调整 调整命令直接修改所选图层中的像素数据，但调整图层中国年可以达到同样的调整效果但不会修改像素</li>
<li>图层➡新建调整图层 可在图层面板中创建调整图层</li>
</ol>
<h3 id="中性色涂层"><a href="#中性色涂层" class="headerlink" title="中性色涂层"></a>中性色涂层</h3><ol>
<li>使用色阶或曲线校正偏色的照片，通过定义灰色来校正色偏</li>
</ol>
<h3 id="智能对象"><a href="#智能对象" class="headerlink" title="智能对象"></a>智能对象</h3><ol>
<li>智能对象是一个嵌入到当前文档中的文件，它可以包含图像，也可以包含矢量图形</li>
<li>文件➡打开为智能对象 创建智能对象，文件➡置入 将另外一个文件作为智能对象置入到当前文档中</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;图层的设置&quot;&gt;&lt;a href=&quot;#图层的设置&quot; class=&quot;headerlink&quot; title=&quot;图层的设置&quot;&gt;&lt;/a&gt;图层的设置&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;图层控制面板中可以设置不透明度&lt;/li&gt;
&lt;li&gt;混合模式用来控制当前图层中的像素与它下面图层中的像素如
    
    </summary>
    
      <category term="设计知识点记录" scheme="https://lzm420241.github.io/categories/%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="design" scheme="https://lzm420241.github.io/tags/design/"/>
    
      <category term="photoshop" scheme="https://lzm420241.github.io/tags/photoshop/"/>
    
  </entry>
  
  <entry>
    <title>4.图层</title>
    <link href="https://lzm420241.github.io/2017/05/19/design/ps-4/"/>
    <id>https://lzm420241.github.io/2017/05/19/design/ps-4/</id>
    <published>2017-05-19T14:21:28.000Z</published>
    <updated>2018-04-23T06:04:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是图层"><a href="#什么是图层" class="headerlink" title="什么是图层"></a>什么是图层</h3><ol>
<li>图层就如同堆叠在一起的透明纸，每一张纸上都保存着不同的图像。我们可以透过上面图层的透明区域看到下面层的图像</li>
<li>图层面板含有：选取图层类型，打开／关闭图层过滤，设置图层的混合模式，设置图层的不透明度，设置填充不透明度，图层锁定按钮，图层链接图标</li>
</ol>
<h3 id="新建图层"><a href="#新建图层" class="headerlink" title="新建图层"></a>新建图层</h3><ol>
<li>点击图层面板中心间图层按钮即在当前图层上面新建一个图层，按住Ctrl键然后点击图层即可在当前图层下面新建图层–图层➡新建➡图层</li>
<li>如果在图像中创建了选区，通过图层➡新建➡通过拷贝的图层或按下Ctrl+J的方式将选区的图层拷贝到当前图层上面，剪切为Shift+Ctrl+J</li>
<li>如果没有背景图层，那么通过图层➡新建➡背景图层来将选中图层转为背景图层</li>
</ol>
<h3 id="编辑图层"><a href="#编辑图层" class="headerlink" title="编辑图层"></a>编辑图层</h3><ol>
<li>选择所有图层-选择➡所有图层，选择链接图层-图层➡选择链接图层，取消选择图层-选择➡取消选择图层</li>
<li>图层➡重命名图层</li>
<li>锁定图层：锁定透明度像素，锁定图像像素，锁定位置，锁定全部</li>
<li>查找图层：选择➡查找图层</li>
<li>删除图层：图层➡删除</li>
<li>栅格化图层内容-如果要使用绘画工具和滤镜编辑文字图层，形状图层，矢量蒙版，让图层内容转化为光栅图像，才能进行编辑 图层➡栅格化</li>
<li>清除图像的杂边 图层➡修边</li>
</ol>
<h3 id="排列与分布图层"><a href="#排列与分布图层" class="headerlink" title="排列与分布图层"></a>排列与分布图层</h3><ol>
<li>图层➡排列 置为顶层，前移一层／后移一层，置为底层，反向</li>
<li>图层➡对齐，图层➡对齐➡顶边</li>
<li>分布图层：图层➡分布➡水平居中</li>
<li>将图层与选区对齐：图层➡将图层与选区对齐</li>
</ol>
<h3 id="合并与盖印图层"><a href="#合并与盖印图层" class="headerlink" title="合并与盖印图层"></a>合并与盖印图层</h3><ol>
<li>合并图层：图层➡合并图层，图层➡向下合并，快捷键Ctrl+E，图层➡合并可见图层，快捷键Shift+Ctrl+E</li>
<li>将图层合并到背景中：图层➡拼合图像</li>
<li>盖印是将多个图层中图像合并到一个新的图层中，同时保持其他图层完好无损，向下盖印快捷键Ctrl+ALt+E，盖印多个图层-选择多个图层，按下Ctrl+Alt+E，盖印可见图层，盖印图层组</li>
</ol>
<h3 id="用图层组管理图层"><a href="#用图层组管理图层" class="headerlink" title="用图层组管理图层"></a>用图层组管理图层</h3><ol>
<li>创建图层组：点击图层面板中的文件夹图标或图层➡新建➡组</li>
<li>从所选图层中创建图层组：图层➡图层编组或Ctrl+G</li>
<li>取消图层组，但保留图层可选择该图层组，执行图层➡取消图层编组或Shift+Ctrl+G，如果要删除整个图层组将其移入图层面板的删除图标</li>
</ol>
<h3 id="图层样式"><a href="#图层样式" class="headerlink" title="图层样式"></a>图层样式</h3><ol>
<li>添加图层样式：1.图层➡图层样式 选择一个有效的命令；2.可以在图层面板中点击图层样式按钮</li>
<li>图层样式对话框中的效果名称前面的复选框如果选中则可以停用该效果，但保留效果参数</li>
<li>斜面和浮雕：对图层添加高光和阴影的各种组合，使图层呈现立体的浮雕效果</li>
<li>描边：可以使用颜色，渐变或图案描画对象的轮廓，它对于硬边形状，如文字特别有用</li>
<li>内阴影：在紧靠图层内容的边缘内添加阴影，使图层内容产生凹陷效果</li>
<li>内发光：沿图层内容的边缘向内创建发光效果</li>
<li>光泽： 应用光滑光泽的内部阴影，通常用来创建金属表面的光泽外观</li>
<li>颜色叠加：在图层上叠加指定的颜色，通过设置颜色的混合模式和不透明度，可以控制叠加效果</li>
<li>渐变叠加：在图层上叠加指定的渐变颜色</li>
<li>图案叠加：在图层上叠加指定的图案并且可以缩放图案，设置图案的不透明度和混合模式</li>
<li>外发光：沿图层内容的边缘向外创建发光效果</li>
<li>投影：为图层内容添加阴影</li>
</ol>
<h3 id="编辑图层样式"><a href="#编辑图层样式" class="headerlink" title="编辑图层样式"></a>编辑图层样式</h3><ol>
<li>显示与隐藏-图层面板中点击眼睛图标可以显示或者隐藏图层</li>
<li>修改效果-双击图层一个效果名称可以打开图层样式对话框，并且可以修改样式参数</li>
<li>复制，粘贴与清除效果-图层➡图层样式➡拷贝图层样式 复制图层样式，粘贴图层样式-图层➡图层样式➡粘贴图层样式</li>
<li>移动图层样式-按住Alt键，然后将图层fx移动到另外一个图层达到移动效果</li>
<li>如果要删除图层样式，将其移动到图层面板中的垃圾桶图标</li>
<li>使用全局光-在图层样式中，投影，内阴影，斜面和浮雕都包含全局光，选择此选项后，以上效果都会使用相同角度的光源</li>
<li>使用等高线-投影，内阴影，内发光，外发光，斜面和浮雕，光泽都包含等高线设置选项，等高线可以选择一个预设的等高线样式</li>
</ol>
<h3 id="使用样式面板"><a href="#使用样式面板" class="headerlink" title="使用样式面板"></a>使用样式面板</h3><ol>
<li>选择一个图层，点击样式面板中一个样式，既可为其添加样式</li>
<li>创建样式，删除样式 样式面板底部有创建样式和删除样式的图标</li>
<li>存储样式库，载入样式库</li>
</ol>
<h3 id="图层复合"><a href="#图层复合" class="headerlink" title="图层复合"></a>图层复合</h3><ol>
<li>图层复合面板用来创建，编辑，显示和删除图层复合</li>
<li>窗口➡图层复合 打开图层复合窗口</li>
<li>图层复合时面板状态的快照，它记录当前文档图层的可见性，位置和外观，通过图层复合可以快速在文档中切换不同版面的显示状态，比较适合多种设计方案</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是图层&quot;&gt;&lt;a href=&quot;#什么是图层&quot; class=&quot;headerlink&quot; title=&quot;什么是图层&quot;&gt;&lt;/a&gt;什么是图层&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;图层就如同堆叠在一起的透明纸，每一张纸上都保存着不同的图像。我们可以透过上面图层的透明区域看到下面层的图
    
    </summary>
    
      <category term="设计知识点记录" scheme="https://lzm420241.github.io/categories/%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="design" scheme="https://lzm420241.github.io/tags/design/"/>
    
      <category term="photoshop" scheme="https://lzm420241.github.io/tags/photoshop/"/>
    
  </entry>
  
  <entry>
    <title>3.选区</title>
    <link href="https://lzm420241.github.io/2017/05/18/design/ps-3/"/>
    <id>https://lzm420241.github.io/2017/05/18/design/ps-3/</id>
    <published>2017-05-18T15:25:13.000Z</published>
    <updated>2018-04-23T06:04:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="认识选区"><a href="#认识选区" class="headerlink" title="认识选区"></a>认识选区</h3><ol>
<li>选区分为两种:普通选区和羽化的选区</li>
<li>选择和抠图的几种方法：1.基本形状选择法；2.色调差异选择法；3.快速蒙版选择法；4.简单选区细化法；5.钢笔工具选择法；6.通道选择法；7.插件选择法；</li>
</ol>
<h3 id="选区的基本操作"><a href="#选区的基本操作" class="headerlink" title="选区的基本操作"></a>选区的基本操作</h3><ol>
<li>全选与反选 选择➡全部或Ctrl+A可以选择当前文件全部图像</li>
<li>复制选区 快捷键Ctrl+C可复制整个图像 如果文档中有多个图层可按下Shift+Ctrl+C</li>
<li>反选 选择➡反向或Shift+Ctrl+I可执行反选</li>
<li>取消选择分区 选择➡取消选择或Ctrl+D可以取消选择，如果要重新选择可以执行选择➡重新选择</li>
<li>选区运算 在工具选项栏中有：新选区，与选区交叉，添加到选区，从选区中减去，与选区这四种运算</li>
<li>如果当前有选区可以使用选框，套索，魔棒工具继续选区，按住Shift可以在当前选区添加选区，等同上</li>
<li>移动选区 隐藏与显示选区 执行视图➡显示➡选区边缘或Ctrl+H可以隐藏选区</li>
<li>选区工具：矩形选区，椭圆选区，单行选区工具，单列选区工具，套索工具，多边形套索工具，磁性套索工具</li>
</ol>
<h3 id="魔棒与快速选择工具"><a href="#魔棒与快速选择工具" class="headerlink" title="魔棒与快速选择工具"></a>魔棒与快速选择工具</h3><ol>
<li>魔棒工具和快速选择工具是基于色调和颜色差异来构建选区的工具</li>
<li>魔棒工具和快速选择工具的工具选项栏</li>
</ol>
<h3 id="“色彩范围”命令"><a href="#“色彩范围”命令" class="headerlink" title="“色彩范围”命令"></a>“色彩范围”命令</h3><ol>
<li>选择➡色彩范围 对话框中有选区预览图，选择-取样颜色，选区预览，检测人脸，反相等。</li>
</ol>
<h3 id="快速蒙版"><a href="#快速蒙版" class="headerlink" title="快速蒙版"></a>快速蒙版</h3><ol>
<li>快速蒙版是一种选区的转换工具，他能将选区转换为一种临时的蒙版图像，这样能通过画笔，滤镜，钢笔等工具编辑蒙版，之后再将蒙版图像转换选区</li>
<li>选择➡在快速蒙版模式下编辑 工具栏底部有快速蒙版编辑工具</li>
</ol>
<h3 id="细化选区"><a href="#细化选区" class="headerlink" title="细化选区"></a>细化选区</h3><ol>
<li>选择➡调整边缘</li>
</ol>
<h3 id="选区的编辑操作"><a href="#选区的编辑操作" class="headerlink" title="选区的编辑操作"></a>选区的编辑操作</h3><ol>
<li>选择➡修改➡边界 可以将选区的边界向内部和外部扩展</li>
<li>选择➡修改➡平滑 让选区更加平滑</li>
<li>选择➡修改➡扩展／收缩 扩展／收缩选区范围</li>
<li>选择➡修改➡羽化 选区羽化，且控制羽化范围</li>
<li>选择➡变换选区 对选区应用进行变换</li>
<li>存储选区–单机通道面板底部将选区存储为通道按钮，将选区保存在Alpha通道中</li>
<li>选择➡存储选区 也可以存储选区</li>
<li>选择➡载入选区 即可载入选区，或者按住Ctrl单击通道缩览图</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;认识选区&quot;&gt;&lt;a href=&quot;#认识选区&quot; class=&quot;headerlink&quot; title=&quot;认识选区&quot;&gt;&lt;/a&gt;认识选区&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;选区分为两种:普通选区和羽化的选区&lt;/li&gt;
&lt;li&gt;选择和抠图的几种方法：1.基本形状选择法；2.色调差异选择
    
    </summary>
    
      <category term="设计知识点记录" scheme="https://lzm420241.github.io/categories/%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="design" scheme="https://lzm420241.github.io/tags/design/"/>
    
      <category term="photoshop" scheme="https://lzm420241.github.io/tags/photoshop/"/>
    
  </entry>
  
  <entry>
    <title>2.图像的基本编辑方法</title>
    <link href="https://lzm420241.github.io/2017/05/17/design/ps-2/"/>
    <id>https://lzm420241.github.io/2017/05/17/design/ps-2/</id>
    <published>2017-05-17T14:37:31.000Z</published>
    <updated>2018-04-23T06:04:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><ol>
<li>Ctrl+N快速新建文件  文件➡新建</li>
<li>Ctrl+O打开文件</li>
<li>图层➡图层样式➡外发光可以调节光晕</li>
<li>文件➡导入可以导入视频帧和WIA等内容</li>
<li>Ctrl+S可以保存文件</li>
<li>Ctrl+W可以关闭文件</li>
</ol>
<h3 id="在图像中添加版权信息"><a href="#在图像中添加版权信息" class="headerlink" title="在图像中添加版权信息"></a>在图像中添加版权信息</h3><ol>
<li>文件➡文件简介可以添加版权信息</li>
<li>使用“嵌入水印”滤镜也可以在图像中加入版权信息</li>
</ol>
<h3 id="修改像素尺寸和画布大小"><a href="#修改像素尺寸和画布大小" class="headerlink" title="修改像素尺寸和画布大小"></a>修改像素尺寸和画布大小</h3><ol>
<li>图像➡图像大小 命令可以设置图像大小</li>
<li>图像大小弹出窗中可以设置文档大小，当缩小图像时会减少像素数量，但是画质不变，但是增大图像时，画质会下降</li>
<li>图像➡画布大小 调整画布的大小</li>
<li>图像➡图像旋转 旋转画布</li>
<li>图像➡复制 复制文档</li>
<li>编辑➡拷贝 拷贝文档 快捷键:Ctrl+C</li>
<li>编辑➡剪切 剪切文档</li>
<li>编辑➡粘贴 粘贴文档 快捷键:Ctrl+V</li>
<li>编辑➡选择性粘贴</li>
<li>编辑➡清楚 清楚选中的图像</li>
<li>编辑➡还原 撤销最后一次修改 快捷键:Ctrl+Z</li>
<li>编辑➡后退一步 可以后退上一步，编辑➡重做 可还原初始 快捷键:Shift+Ctrl+Z</li>
<li>文件➡恢复 直接将文件恢复到最后一次保存状态</li>
<li>tips—图像➡调整以及滤镜菜单中的滤镜，当我们修改参数时，若要还原默认值可以按住Alt键，对话框中的取消会变成复位</li>
</ol>
<h3 id="用历史记录面板进行还原操作"><a href="#用历史记录面板进行还原操作" class="headerlink" title="用历史记录面板进行还原操作"></a>用历史记录面板进行还原操作</h3><ol>
<li>窗口➡历史记录 可查看操作的历史记录</li>
<li>历史记录只能保存20步的操作步骤</li>
<li>若要增加步数可在 编辑➡首选项➡性能对话框中增加历史记录的保存步数，但是这样会占用很多内存</li>
<li>另外一种方式是绘制完重要的效果之后可在历史记录面板中点击快照按钮，将画面的当前状态保存为一个快照，按住Alt键然后点击快照按钮即可创建快照</li>
<li>删除快照–将快照移入删除按钮中</li>
<li>编辑➡清理 将菜单中的历史记录和全部命令会清除ps打开的所有文档</li>
</ol>
<h3 id="图像的变换和变形操作"><a href="#图像的变换和变形操作" class="headerlink" title="图像的变换和变形操作"></a>图像的变换和变形操作</h3><ol>
<li>编辑➡变换 可以对涂层，路径，矢量形状，以及选中的图像进行变换操作</li>
<li>移动工具选项栏中可以点击显示变换控件，即可变形图像</li>
<li>移动工具快速调入变换状态快捷键:Ctrl+T，变换图像，且复制出新的图像内容快捷键:Alt+Shfit+Ctrl+T</li>
<li>复制图层快捷键:Ctrl+J</li>
</ol>
<h3 id="内容识别比例缩放"><a href="#内容识别比例缩放" class="headerlink" title="内容识别比例缩放"></a>内容识别比例缩放</h3><ol>
<li>将背景图层转换普通图层快捷键:安装ALt然后双击图层</li>
<li>编辑➡内容识别比例</li>
<li>取消选取快捷键:Ctrl+D</li>
<li>用Alpha通道保护图像–在使用内容缩放时容易导致图像变形，为了保护部分地方不变形，选择受保护选取然后点击通道的蒙版，将选取保存为Alpha通道</li>
</ol>
<h3 id="操控变形"><a href="#操控变形" class="headerlink" title="操控变形"></a>操控变形</h3><ol>
<li>编辑➡操控变形 可以操控变形</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;新建文件&quot;&gt;&lt;a href=&quot;#新建文件&quot; class=&quot;headerlink&quot; title=&quot;新建文件&quot;&gt;&lt;/a&gt;新建文件&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Ctrl+N快速新建文件  文件➡新建&lt;/li&gt;
&lt;li&gt;Ctrl+O打开文件&lt;/li&gt;
&lt;li&gt;图层➡图层样式
    
    </summary>
    
      <category term="设计知识点记录" scheme="https://lzm420241.github.io/categories/%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="design" scheme="https://lzm420241.github.io/tags/design/"/>
    
      <category term="photoshop" scheme="https://lzm420241.github.io/tags/photoshop/"/>
    
  </entry>
  
  <entry>
    <title>你不知道javascript（上卷）知识点总结</title>
    <link href="https://lzm420241.github.io/2017/05/17/javascript/javascript/"/>
    <id>https://lzm420241.github.io/2017/05/17/javascript/javascript/</id>
    <published>2017-05-17T11:24:32.000Z</published>
    <updated>2018-04-23T06:02:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ol>
<li>编译的三步骤:分词／词法分析，解析／语法分析，代码生成</li>
<li>javascript编译器工作过程:1.在当前作用域中声明一个变量（如果之前没有声明）；2.在运行时引擎会在作用域中查找该变量，如果能够找到变量就会对它赋值</li>
<li>编译器查找变量的方法是通过LHS查询和RHS查询，当变量出现在赋值操作的左侧时执行LHS查询，当赋值出现在右侧时进行的是RHS查询</li>
<li>当一个块或函数嵌套在另一个块或函数时，就发生了作用域的嵌套，因此，在当前作用域中无法找到某个变量时，引擎会在外层作用域中查找，直到找到该变量，或抵达最外层作用域停止</li>
<li>在非严格模式下，如果通过RHS查询无法查询到变量，但是通过LHS查询时如果不存在这个变量会自动声明这个变量，在严格模式下两者查询模式都是不行的 </li>
</ol>
<h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><ol>
<li>作用域共有两种工作模型:1.词法作用域；2.动态作用域</li>
<li>词法作用域就是定义在词法阶段的作用域</li>
<li><p>欺骗词法的两种机制(非常影响性能):<br>1.eval函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码，严格模式的声明是无法修改所在的作用域    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>)</span>&#123;</div><div class="line">    <span class="built_in">eval</span>(str);  <span class="comment">//欺骗</span></div><div class="line">    <span class="built_in">console</span>.log(a, b);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line">foo(<span class="string">"var b = 3;"</span>, <span class="number">1</span>) <span class="comment">//1,3</span></div></pre></td></tr></table></figure>
<p>2.with关键字通常被当作重复引用同一个对象中的多个属性的快捷方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">b</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">c</span>: <span class="number">3</span></div><div class="line">&#125;</div><div class="line">obj.a = <span class="number">2</span>;</div><div class="line">obj.b = <span class="number">3</span>;</div><div class="line">obj.c = <span class="number">4</span>;</div><div class="line"><span class="comment">//简单的快捷方式</span></div><div class="line"><span class="keyword">with</span>(obj)&#123;</div><div class="line">    a = <span class="number">3</span>;</div><div class="line">    b = <span class="number">4</span>;</div><div class="line">    c = <span class="number">5</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h4><ol>
<li>函数会被当作函数表达式而不是一个标准的函数声明来处理</li>
<li>width，try／catch中的catch都是块作用域中例子</li>
</ol>
<h4 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h4><ol>
<li>包含变量和函数在内的所有声明都会在任何代码被执行前首先被处理</li>
<li>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升该拜年了代码的顺序，会造成严重的破坏</li>
<li>函数声明会被提升，但是函数表达式却不会被提升</li>
<li>函数会首先被提升，然后才是变量</li>
<li>代码执行会经过两个阶段任务:1.编译阶段的人物；2.执行阶段任务</li>
</ol>
<h4 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h4><ol>
<li>无论通过任何手段将内部函数传递到所在的词法作用域以外，他都会持有对原始定义作用域的引用，无论在何处执行这个函数都是使用闭包</li>
<li>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包</li>
</ol>
<h4 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h4><ol>
<li>词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的，词法作用域关注函数在何处声明，动态作用域关注函数从何处调用</li>
</ol>
<h3 id="this和对象原型"><a href="#this和对象原型" class="headerlink" title="this和对象原型"></a>this和对象原型</h3><h4 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h4><ol>
<li>arguments.callee目前唯一一种从匿名函数对象内部引用自身的方法</li>
<li>this是在运行时调用的，并不是在编写时绑定的。这个记录会包含函数在哪里被调用，函数的调用方法，传入参数等信息。this就是记录的其中一个属性，会在函数执行的过程中用到</li>
<li>this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用</li>
</ol>
<h4 id="this全面解析"><a href="#this全面解析" class="headerlink" title="this全面解析"></a>this全面解析</h4><ol>
<li>调用位置:函数在代码中被调用的位置，而不是声明的位置</li>
<li>查看绑定规则:1.默认绑定；2.隐式绑定；3.显式绑定（call和apply）；4.new绑定</li>
<li>四种绑定的优先级:new绑定&gt;显示绑定&gt;隐式绑定&gt;默认绑定</li>
<li>将null和undefined通过call或apply传入函数实际等价于默认绑定</li>
<li>软绑定➡如果给默认绑定指定一个全局对象和undefined以外的值，那就可以和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改this的能力</li>
<li></li>
</ol>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ol>
<li>对象可以通过声明形式和构造形式定义</li>
<li>六种类型:string，number，boolean，null，undefined，object</li>
<li>对象子类型:String，Number，Boolean，Object，Function，Array，Date，RegExp，Error</li>
<li>在对象中属性名永远都是字符串，如果使用了string以外的值，那么它首先会转化为字符串</li>
<li>函数和方法本质是等价的，唯一不同的是方法里面使用的this会隐式指向对象</li>
<li>浅复制即对值的引用，深复制会复制其相关联的元素</li>
<li>object.assign实现浅复制</li>
<li><p>通过object.defineProperty来添加一个新属性或者修改一个已有的属性，并对特性进行设置     </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObj = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(myObj, <span class="string">"a"</span>, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>禁用扩展 Object.preventExtensions</p>
</li>
<li>密封 Object.seal 不可重新配置也不可删除任何现有属性</li>
<li>冻结 Object.freeze 对象上最高级别的不可用性</li>
<li>Object.hasOwnProperty检查属性是否存在对象中</li>
<li>Object.propertyIsEnumerable检查给定属性名是否直接存在于对象中，Object.keys返回可枚举属性的数组，Object.getOwnPropertyNames 返回一个数组，包含所有属性</li>
<li>forEach遍历数组的所有值，并忽略回调函数的返回值</li>
<li>every（）和some（）中特殊的返回值类似for里面的break</li>
<li>for…of..会寻找内置或者自定义的@@iterator对象并调用它的next（）方法来遍历数据值</li>
</ol>
<h4 id="混合对象“类”"><a href="#混合对象“类”" class="headerlink" title="混合对象“类”"></a>混合对象“类”</h4><ol>
<li>面向类的设计模式：实例化，继承，多台</li>
<li>多态是说父类的通用行为可以被子类更特殊的行为重写</li>
<li><p>类实例由一个特殊的方法构造，成为构造函数，这个方法的任务就是初始化实例需要的所有信息  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoolGuy</span> </span>&#123;</div><div class="line">    specialTrick = nothing;</div><div class="line">    CoolGuy(trick) &#123;</div><div class="line">        specialTrick = trick;</div><div class="line">    &#125;</div><div class="line">    showOff()&#123;</div><div class="line">        output(<span class="string">"Here's my trick: "</span>, specialTrick)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Joe = <span class="keyword">new</span> CoolGuy(<span class="string">"jumping rope"</span>);</div><div class="line">Joe.showOff();</div></pre></td></tr></table></figure>
</li>
<li><p>javascript本身不提供多重继承，但是可以通过各种办法来实现多重继承</p>
</li>
<li>模拟类的复制：显示和隐式</li>
<li><p>显示混入实现类似于extend </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params"> sourceObj, targetObj</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> sourceObj)&#123;</div><div class="line">        <span class="keyword">if</span>(!(key <span class="keyword">in</span> targetObj))&#123;</div><div class="line">            targetObj[key] = sourceObj[key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> targetObj;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> Vehicle = &#123;</div><div class="line">    <span class="attr">engine</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">ignition</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Turning on my engine"</span>);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">drive</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.ignition();</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Steering and moving forward"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> Car = mixin(Vehicle, &#123;</div><div class="line">    <span class="attr">wheels</span>: <span class="number">4</span>,</div><div class="line">    <span class="attr">drive</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        Vehicle.drive.call(<span class="keyword">this</span>);</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Rolling on all"</span> + <span class="keyword">this</span>.wheels + <span class="string">"whells"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>隐式混入    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoolGuy</span> </span>&#123;</div><div class="line">    specialTrick = nothing;</div><div class="line">    CoolGuy(trick) &#123;</div><div class="line">        specialTrick = trick;</div><div class="line">    &#125;</div><div class="line">    showOff()&#123;</div><div class="line">        output(<span class="string">"Here's my trick: "</span>, specialTrick)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Joe = <span class="keyword">new</span> CoolGuy(<span class="string">"jumping rope"</span>);</div><div class="line">Joe.showOff();</div></pre></td></tr></table></figure>
</li>
<li><p>javascript本身不提供多重继承，但是可以通过各种办法来实现多重继承</p>
</li>
<li>模拟类的复制：显示和隐式</li>
<li><p>显示混入实现类似于extend </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Something = &#123;</div><div class="line">    <span class="attr">cool</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.greeting = <span class="string">"hello, world"</span>;</div><div class="line">        <span class="keyword">this</span>.count = <span class="keyword">this</span>.count?<span class="keyword">this</span>.count+<span class="number">1</span>:<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Something.cool();</div><div class="line">Something.greeting;</div><div class="line">Something.count;</div><div class="line"><span class="keyword">var</span> Another = &#123;</div><div class="line">    <span class="attr">cool</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        Something.cool.call(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Another.cool();</div><div class="line">Another.greeting;</div><div class="line">Another.count;</div></pre></td></tr></table></figure>
</li>
<li><p>类意味着复制</p>
</li>
</ol>
<h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><ol>
<li>javascript中的对象有一个特殊的[[prototype]]内置属性，其实就是对于其他对象的引用</li>
<li>所有的普通[[prototype]]链都会指向内置的object.prototype</li>
<li>所有的函数类默认都会拥有一个名为prototype的公有并且不可枚举的属性，它指向另一个对象</li>
<li>javascript不能创建一个类的多个实例，只能创建多个对象，他们关联到同一个对象</li>
<li>new会劫持所有普通函数并且用构造对象的形式来调用它</li>
</ol>
<h4 id="行为委托"><a href="#行为委托" class="headerlink" title="行为委托"></a>行为委托</h4><ol>
<li>如果在第一个对象上没有找到需要的属性或者方法引用，引擎就会继续在关联的对象上进行查找，如果后者还是没找到则会继续查找他的prototype，这一系列对象的链接称为“原型链”</li>
<li>委托行为意味着某些对象在找不到属性或者方法引用时会把这个请求委托给另一个对象</li>
<li>无法在两个或者两个以上相互为多的对象之间创建循环委托</li>
<li>Object.create()方法使用指定的原型对象和其属性创建了一个新的对象</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;作用域和闭包&quot;&gt;&lt;a href=&quot;#作用域和闭包&quot; class=&quot;headerlink&quot; title=&quot;作用域和闭包&quot;&gt;&lt;/a&gt;作用域和闭包&lt;/h3&gt;&lt;h4 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域
    
    </summary>
    
      <category term="前端知识点总结" scheme="https://lzm420241.github.io/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="javascript" scheme="https://lzm420241.github.io/tags/javascript/"/>
    
      <category term="你不知道的javascript" scheme="https://lzm420241.github.io/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript/"/>
    
  </entry>
  
  <entry>
    <title>1.ps基本操作</title>
    <link href="https://lzm420241.github.io/2017/05/17/design/building-basic-task-for-photoshop/"/>
    <id>https://lzm420241.github.io/2017/05/17/design/building-basic-task-for-photoshop/</id>
    <published>2017-05-16T16:04:10.000Z</published>
    <updated>2018-04-23T06:07:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ps基本工作界面"><a href="#ps基本工作界面" class="headerlink" title="ps基本工作界面"></a>ps基本工作界面</h3><ol>
<li>界面分为菜单栏，工具选项栏，工具箱，选项卡，文档窗口，面板这几部分</li>
<li>文档窗口:<strong>ctrl+Tab快捷键可切换界面</strong></li>
<li>工具箱分为选择工具，裁剪和切片，测量工具，修饰工具，绘画工具，导航工具等几种类别工具</li>
</ol>
<h3 id="查看图像"><a href="#查看图像" class="headerlink" title="查看图像"></a>查看图像</h3><ol>
<li>工具箱底部的屏幕模式按钮可查看标准屏幕，全屏模式，菜单栏的全屏模式</li>
<li>在多个窗口查看图像可在<strong>窗口&gt;排列</strong>中选择哪种展示方式</li>
<li>旋转视图工具可旋转画布<strong>在工具栏中使用旋转工具</strong></li>
<li>在工具栏中使用缩放工具来调整窗口比例<strong>按住Alt键可缩小窗口</strong></li>
<li>在工具栏中用抓手工具移动画面<strong>Alt键缩小窗口，command键放大窗口，按住H键然后单击鼠标会显示全部图像，并且出现一个矩形框，放开H键和鼠标可移动到某块区域</strong></li>
<li>在<strong>窗口&gt;导航器</strong>中查看图像，<strong>通过扩大和缩小来查看图片，右键点击图像以外的暂存区可选择背景颜色</strong></li>
<li>在<strong>窗口&gt;工作区</strong>使用预设工作区</li>
<li>在菜单栏中的<strong>编辑&gt;菜单</strong>中打开键盘快捷键合菜单，<strong>点击菜单tab可定义菜单中各种颜色，在键盘快捷键中可自定义快捷键</strong></li>
</ol>
<h3 id="使用辅助工具"><a href="#使用辅助工具" class="headerlink" title="使用辅助工具"></a>使用辅助工具</h3><ol>
<li>在<strong>视图&gt;标尺</strong>中使用标尺，在窗口左上角向右下方拉可以设置坐标原点</li>
<li>在标尺中可以拉出参考线，如果要删除参考线则拉到标尺里面就删除了</li>
<li>在<strong>视图&gt;显示&gt;网格</strong>中使用网格</li>
<li>在工具栏中使用注释工具可在图像中添加注释</li>
</ol>
<h3 id="附几个快捷键"><a href="#附几个快捷键" class="headerlink" title="附几个快捷键:"></a>附几个快捷键:</h3><ol>
<li>Ctrl+o可以快速打开文件</li>
<li>Ctrl++可以放大图片，Ctrl+-可以缩小图片</li>
<li>Ctrl+R可以打开标尺，再使用一次关闭标尺</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ps基本工作界面&quot;&gt;&lt;a href=&quot;#ps基本工作界面&quot; class=&quot;headerlink&quot; title=&quot;ps基本工作界面&quot;&gt;&lt;/a&gt;ps基本工作界面&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;界面分为菜单栏，工具选项栏，工具箱，选项卡，文档窗口，面板这几部分&lt;/li&gt;
&lt;
    
    </summary>
    
      <category term="设计知识点记录" scheme="https://lzm420241.github.io/categories/%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="design" scheme="https://lzm420241.github.io/tags/design/"/>
    
      <category term="photoshop" scheme="https://lzm420241.github.io/tags/photoshop/"/>
    
  </entry>
  
  <entry>
    <title>页面设计的四条原则</title>
    <link href="https://lzm420241.github.io/2017/05/15/design/page-design/"/>
    <id>https://lzm420241.github.io/2017/05/15/design/page-design/</id>
    <published>2017-05-15T13:18:05.000Z</published>
    <updated>2018-04-23T06:04:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网页设计四条原则"><a href="#网页设计四条原则" class="headerlink" title="网页设计四条原则"></a>网页设计四条原则</h3><p><strong>原则一:设计之对比色原则</strong></p>
<pre><code>主要目的是突出重点，将内容区分出来
</code></pre><p><strong>原则二:设计之对奇原则</strong>     </p>
<pre><code>主要是更好地展示网页信息，样式清晰,所有设计元素和页面上其他元素要有视觉上的练习
</code></pre><p><strong>原则三:设计之重复性原则</strong>    </p>
<pre><code>主要目的是保持整个页面统一的风格，各个页面的风格不会互相冲突
</code></pre><p><strong>原则四:设计之相似性原则</strong>    </p>
<pre><code>主要是将相似的元素放倒一起，这样使用户易于查找    
</code></pre><p><strong>附带</strong><a href="http://colorschemedesigner.com/csd-3.5/" target="_blank" rel="external">页面选色在线网站</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;网页设计四条原则&quot;&gt;&lt;a href=&quot;#网页设计四条原则&quot; class=&quot;headerlink&quot; title=&quot;网页设计四条原则&quot;&gt;&lt;/a&gt;网页设计四条原则&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;原则一:设计之对比色原则&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    
    </summary>
    
      <category term="设计知识点记录" scheme="https://lzm420241.github.io/categories/%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="design" scheme="https://lzm420241.github.io/tags/design/"/>
    
  </entry>
  
</feed>
